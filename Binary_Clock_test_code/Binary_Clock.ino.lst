
/tmp/arduino_build_267300/Binary_Clock.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	2c c0       	rjmp	.+88     	; 0x5a <__ctors_end>
   2:	45 c0       	rjmp	.+138    	; 0x8e <__bad_interrupt>
   4:	44 c0       	rjmp	.+136    	; 0x8e <__bad_interrupt>
   6:	43 c0       	rjmp	.+134    	; 0x8e <__bad_interrupt>
   8:	42 c0       	rjmp	.+132    	; 0x8e <__bad_interrupt>
   a:	41 c0       	rjmp	.+130    	; 0x8e <__bad_interrupt>
   c:	40 c0       	rjmp	.+128    	; 0x8e <__bad_interrupt>
   e:	3f c0       	rjmp	.+126    	; 0x8e <__bad_interrupt>
  10:	3e c0       	rjmp	.+124    	; 0x8e <__bad_interrupt>
  12:	3d c0       	rjmp	.+122    	; 0x8e <__bad_interrupt>
  14:	3c c0       	rjmp	.+120    	; 0x8e <__bad_interrupt>
  16:	67 c3       	rjmp	.+1742   	; 0x6e6 <__vector_11>
  18:	3a c0       	rjmp	.+116    	; 0x8e <__bad_interrupt>
  1a:	39 c0       	rjmp	.+114    	; 0x8e <__bad_interrupt>
  1c:	38 c0       	rjmp	.+112    	; 0x8e <__bad_interrupt>
  1e:	27 c4       	rjmp	.+2126   	; 0x86e <__vector_15>
  20:	ac c3       	rjmp	.+1880   	; 0x77a <__vector_16>

00000022 <__trampolines_end>:
__trampolines_start():
  22:	00 00       	nop
  24:	3b 00       	.word	0x003b	; ????
  26:	38 00       	.word	0x0038	; ????

00000028 <port_to_mode_PGM>:
  28:	00 00 3a 00 37 00                                   ..:.7.

0000002e <port_to_input_PGM>:
  2e:	00 00 39 00 36 00                                   ..9.6.

00000034 <digital_pin_to_port_PGM>:
  34:	01 01 01 01 01 01 01 01 02 02 02 02                 ............

00000040 <digital_pin_to_bit_mask_PGM>:
  40:	01 02 04 08 10 20 40 80 04 02 01 08                 ..... @.....

0000004c <digital_pin_to_timer_PGM>:
  4c:	00 00 00 00 00 04 03 02 01 00 00 00                 ............

00000058 <__ctors_start>:
__ctors_start():
  58:	9d 06       	cpc	r9, r29

0000005a <__ctors_end>:
__dtors_end():
  5a:	11 24       	eor	r1, r1
  5c:	1f be       	out	0x3f, r1	; 63
  5e:	cf e5       	ldi	r28, 0x5F	; 95
  60:	d2 e0       	ldi	r29, 0x02	; 2
  62:	de bf       	out	0x3e, r29	; 62
  64:	cd bf       	out	0x3d, r28	; 61

00000066 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  66:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  68:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  6a:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  6c:	01 c0       	rjmp	.+2      	; 0x70 <.do_clear_bss_start>

0000006e <.do_clear_bss_loop>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  6e:	1d 92       	st	X+, r1

00000070 <.do_clear_bss_start>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  70:	a9 3b       	cpi	r26, 0xB9	; 185
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  72:	b2 07       	cpc	r27, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  74:	e1 f7       	brne	.-8      	; 0x6e <.do_clear_bss_loop>

00000076 <__do_global_ctors>:
__do_global_ctors():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  76:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  78:	cd e2       	ldi	r28, 0x2D	; 45
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  7a:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  7c:	03 c0       	rjmp	.+6      	; 0x84 <__do_global_ctors+0xe>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  7e:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  80:	fe 01       	movw	r30, r28
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  82:	94 d6       	rcall	.+3368   	; 0xdac <__tablejump2__>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  84:	cc 32       	cpi	r28, 0x2C	; 44
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  86:	d1 07       	cpc	r29, r17
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  88:	d1 f7       	brne	.-12     	; 0x7e <__do_global_ctors+0x8>
  8a:	0a d4       	rcall	.+2068   	; 0x8a0 <main>
  8c:	95 c6       	rjmp	.+3370   	; 0xdb8 <_exit>

0000008e <__bad_interrupt>:
__vector_1():
  8e:	b8 cf       	rjmp	.-144    	; 0x0 <__vectors>

00000090 <USIWire::read() [clone .constprop.16]>:
_ZN7USIWire4readEv.constprop.16():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:235

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int USIWire::available(void) {
  if (BufferLength) {
  90:	80 91 b8 00 	lds	r24, 0x00B8	; 0x8000b8 <USIWire::BufferLength>
  94:	88 23       	and	r24, r24
  96:	39 f0       	breq	.+14     	; 0xa6 <USIWire::read() [clone .constprop.16]+0x16>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:236
    return BufferLength - BufferIndex;
  98:	20 91 b7 00 	lds	r18, 0x00B7	; 0x8000b7 <USIWire::BufferIndex>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:249
// or after requestFrom(address, numBytes)
int USIWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (available()) {
  9c:	82 13       	cpse	r24, r18
  9e:	1c c0       	rjmp	.+56     	; 0xd8 <USIWire::read() [clone .constprop.16]+0x48>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:246

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int USIWire::read(void) {
  int value = -1;
  a0:	8f ef       	ldi	r24, 0xFF	; 255
  a2:	9f ef       	ldi	r25, 0xFF	; 255
  a4:	08 95       	ret
USI_TWI_Data_In_Receive_Buffer():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:133

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
	unsigned char tmpRxTail;          // Temporary variable to store volatile
	tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
  a6:	90 91 b6 00 	lds	r25, 0x00B6	; 0x8000b6 <TWI_RxTail>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:134
	return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
  aa:	80 91 b5 00 	lds	r24, 0x00B5	; 0x8000b5 <TWI_RxHead>
  ae:	89 1b       	sub	r24, r25
  b0:	8f 70       	andi	r24, 0x0F	; 15
_ZN7USIWire4readEv.constprop.16():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:249

  // get each successive byte on each call
  if (available()) {
  b2:	b1 f3       	breq	.-20     	; 0xa0 <USIWire::read() [clone .constprop.16]+0x10>
USI_TWI_Receive_Byte():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:109
// Returns a byte from the receive buffer. Waits if buffer is empty.
unsigned char USI_TWI_Receive_Byte(void)
{
	unsigned char tmptail;
	unsigned char tmpRxTail; // Temporary variable to store volatile
	tmpRxTail = TWI_RxTail;  // Not necessary, but prevents warnings
  b4:	90 91 b6 00 	lds	r25, 0x00B6	; 0x8000b6 <TWI_RxTail>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:110
	while (TWI_RxHead == tmpRxTail)
  b8:	80 91 b5 00 	lds	r24, 0x00B5	; 0x8000b5 <TWI_RxHead>
  bc:	98 17       	cp	r25, r24
  be:	e1 f3       	breq	.-8      	; 0xb8 <USIWire::read() [clone .constprop.16]+0x28>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:112
		;
	tmptail    = (TWI_RxTail + 1) & TWI_RX_BUFFER_MASK; // Calculate buffer index
  c0:	e0 91 b6 00 	lds	r30, 0x00B6	; 0x8000b6 <TWI_RxTail>
  c4:	ef 5f       	subi	r30, 0xFF	; 255
  c6:	ef 70       	andi	r30, 0x0F	; 15
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:113
	TWI_RxTail = tmptail;                               // Store new index
  c8:	e0 93 b6 00 	sts	0x00B6, r30	; 0x8000b6 <TWI_RxTail>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:114
	return TWI_RxBuf[tmptail];                          // Return data from the buffer.
  cc:	f0 e0       	ldi	r31, 0x00	; 0
  ce:	e0 5a       	subi	r30, 0xA0	; 160
  d0:	ff 4f       	sbci	r31, 0xFF	; 255
_ZN7USIWire4readEv.constprop.16():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:254
    if (BufferLength) {
      value = Buffer[BufferIndex];
      ++BufferIndex;
    } else {
      value = USI_TWI_Receive_Byte();
  d2:	80 81       	ld	r24, Z
  d4:	90 e0       	ldi	r25, 0x00	; 0
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:259
    }
  }

  return value;
}
  d6:	08 95       	ret
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:251
  int value = -1;

  // get each successive byte on each call
  if (available()) {
    if (BufferLength) {
      value = Buffer[BufferIndex];
  d8:	e2 2f       	mov	r30, r18
  da:	f0 e0       	ldi	r31, 0x00	; 0
  dc:	e0 5a       	subi	r30, 0xA0	; 160
  de:	ff 4f       	sbci	r31, 0xFF	; 255
  e0:	80 81       	ld	r24, Z
  e2:	90 e0       	ldi	r25, 0x00	; 0
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:252
      ++BufferIndex;
  e4:	2f 5f       	subi	r18, 0xFF	; 255
  e6:	20 93 b7 00 	sts	0x00B7, r18	; 0x8000b7 <USIWire::BufferIndex>
  ea:	08 95       	ret

000000ec <USIWire::write(unsigned char) [clone .constprop.15]>:
_ZN7USIWire5writeEh.constprop.15():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:191

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t USIWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
  ec:	90 91 b4 00 	lds	r25, 0x00B4	; 0x8000b4 <USIWire::transmitting>
  f0:	99 23       	and	r25, r25
  f2:	a1 f0       	breq	.+40     	; 0x11c <USIWire::write(unsigned char) [clone .constprop.15]+0x30>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:193
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
  f4:	90 91 b8 00 	lds	r25, 0x00B8	; 0x8000b8 <USIWire::BufferLength>
  f8:	90 32       	cpi	r25, 0x20	; 32
  fa:	40 f5       	brcc	.+80     	; 0x14c <USIWire::write(unsigned char) [clone .constprop.15]+0x60>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:197
      return 0;
    }
    // put byte in tx buffer
    Buffer[BufferIndex] = data;
  fc:	90 91 b7 00 	lds	r25, 0x00B7	; 0x8000b7 <USIWire::BufferIndex>
 100:	e9 2f       	mov	r30, r25
 102:	f0 e0       	ldi	r31, 0x00	; 0
 104:	e0 5a       	subi	r30, 0xA0	; 160
 106:	ff 4f       	sbci	r31, 0xFF	; 255
 108:	80 83       	st	Z, r24
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:198
    ++BufferIndex;
 10a:	81 e0       	ldi	r24, 0x01	; 1
 10c:	89 0f       	add	r24, r25
 10e:	80 93 b7 00 	sts	0x00B7, r24	; 0x8000b7 <USIWire::BufferIndex>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:200
    // update amount in buffer
    BufferLength = BufferIndex;
 112:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <USIWire::BufferLength>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:209
      return 0;
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
 116:	81 e0       	ldi	r24, 0x01	; 1
 118:	90 e0       	ldi	r25, 0x00	; 0
 11a:	08 95       	ret
USI_TWI_Space_In_Transmission_Buffer():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:141

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
	unsigned char tmpTxHead;
	tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
 11c:	20 91 b3 00 	lds	r18, 0x00B3	; 0x8000b3 <TWI_TxHead>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:142
	return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
 120:	90 91 b2 00 	lds	r25, 0x00B2	; 0x8000b2 <TWI_TxTail>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:141

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
	unsigned char tmpTxHead;
	tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
 124:	2f 5f       	subi	r18, 0xFF	; 255
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:142
	return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
 126:	92 1b       	sub	r25, r18
 128:	9f 70       	andi	r25, 0x0F	; 15
_ZN7USIWire5writeEh.constprop.15():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:203
    ++BufferIndex;
    // update amount in buffer
    BufferLength = BufferIndex;
  } else { // in slave send mode
    // don't bother if buffer is full
    if (!USI_TWI_Space_In_Transmission_Buffer()) {
 12a:	81 f0       	breq	.+32     	; 0x14c <USIWire::write(unsigned char) [clone .constprop.15]+0x60>
USI_TWI_Transmit_Byte():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:97
// Puts data in the transmission buffer, Waits if buffer is full.
void USI_TWI_Transmit_Byte(unsigned char data)
{
	unsigned char tmphead;

	tmphead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate buffer index.
 12c:	90 91 b3 00 	lds	r25, 0x00B3	; 0x8000b3 <TWI_TxHead>
 130:	9f 5f       	subi	r25, 0xFF	; 255
 132:	9f 70       	andi	r25, 0x0F	; 15
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:98
	while (tmphead == TWI_TxTail)
 134:	20 91 b2 00 	lds	r18, 0x00B2	; 0x8000b2 <TWI_TxTail>
 138:	92 17       	cp	r25, r18
 13a:	e1 f3       	breq	.-8      	; 0x134 <USIWire::write(unsigned char) [clone .constprop.15]+0x48>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:100
		;                         // Wait for free space in buffer.
	TWI_TxBuf[tmphead] = data;    // Store data in buffer.
 13c:	e9 2f       	mov	r30, r25
 13e:	f0 e0       	ldi	r31, 0x00	; 0
 140:	e0 59       	subi	r30, 0x90	; 144
 142:	ff 4f       	sbci	r31, 0xFF	; 255
 144:	80 83       	st	Z, r24
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:101
	TWI_TxHead         = tmphead; // Store new index.
 146:	90 93 b3 00 	sts	0x00B3, r25	; 0x8000b3 <TWI_TxHead>
 14a:	e5 cf       	rjmp	.-54     	; 0x116 <USIWire::write(unsigned char) [clone .constprop.15]+0x2a>
_ZN7USIWire5writeEh.constprop.15():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:194
// or after beginTransmission(address)
size_t USIWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
      return 0;
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	80 e0       	ldi	r24, 0x00	; 0
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:210
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
}
 150:	08 95       	ret

00000152 <USIWire::beginTransmission(unsigned char) [clone .constprop.10]>:
_ZN7USIWire17beginTransmissionEh.constprop.10():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:146
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
}

void USIWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
 152:	91 e0       	ldi	r25, 0x01	; 1
 154:	90 93 b4 00 	sts	0x00B4, r25	; 0x8000b4 <USIWire::transmitting>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:148
  // set address of targeted slave and write mode
  Buffer[0] = (address << TWI_ADR_BITS) | (0 << TWI_READ_BIT);
 158:	88 0f       	add	r24, r24
 15a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:150
  // reset tx buffer iterator vars
  BufferIndex = 1; // reserved by slave address
 15e:	90 93 b7 00 	sts	0x00B7, r25	; 0x8000b7 <USIWire::BufferIndex>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:151
  BufferLength = BufferIndex;
 162:	90 93 b8 00 	sts	0x00B8, r25	; 0x8000b8 <USIWire::BufferLength>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:152
}
 166:	08 95       	ret

00000168 <micros>:
micros():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:190
}

unsigned long micros()
{
  unsigned long m;
  uint8_t oldSREG = SREG, t;
 168:	3f b7       	in	r19, 0x3f	; 63
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:192

  cli();
 16a:	f8 94       	cli
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:193
  m = millis_timer_overflow_count;
 16c:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <millis_timer_overflow_count>
 170:	90 91 ab 00 	lds	r25, 0x00AB	; 0x8000ab <millis_timer_overflow_count+0x1>
 174:	a0 91 ac 00 	lds	r26, 0x00AC	; 0x8000ac <millis_timer_overflow_count+0x2>
 178:	b0 91 ad 00 	lds	r27, 0x00AD	; 0x8000ad <millis_timer_overflow_count+0x3>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:195
#if defined(TCNT0) && (TIMER_TO_USE_FOR_MILLIS == 0) && !defined(TCW0)
  t = TCNT0;
 17c:	22 b7       	in	r18, 0x32	; 50
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:207
#else
  #error Millis()/Micros() timer not defined
#endif

#if defined(TIFR0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR0 & _BV(TOV0)) && (t < 255))
 17e:	08 b6       	in	r0, 0x38	; 56
 180:	00 fe       	sbrs	r0, 0
 182:	05 c0       	rjmp	.+10     	; 0x18e <micros+0x26>
 184:	2f 3f       	cpi	r18, 0xFF	; 255
 186:	19 f0       	breq	.+6      	; 0x18e <micros+0x26>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:208
    m++;
 188:	01 96       	adiw	r24, 0x01	; 1
 18a:	a1 1d       	adc	r26, r1
 18c:	b1 1d       	adc	r27, r1
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:220
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 1)
  if ((TIFR & _BV(TOV1)) && (t < 255))
    m++;
#endif

  SREG = oldSREG;
 18e:	3f bf       	out	0x3f, r19	; 63
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:227

#if F_CPU < 1000000L
  return ((m << 8) + t) * MillisTimer_Prescale_Value * (1000000L/F_CPU);
#else
#if (MillisTimer_Prescale_Value % clockCyclesPerMicrosecond() == 0 ) // Can we just do it the naive way? If so great!
  return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
 190:	ba 2f       	mov	r27, r26
 192:	a9 2f       	mov	r26, r25
 194:	98 2f       	mov	r25, r24
 196:	88 27       	eor	r24, r24
 198:	bc 01       	movw	r22, r24
 19a:	cd 01       	movw	r24, r26
 19c:	62 0f       	add	r22, r18
 19e:	71 1d       	adc	r23, r1
 1a0:	81 1d       	adc	r24, r1
 1a2:	91 1d       	adc	r25, r1
 1a4:	43 e0       	ldi	r20, 0x03	; 3
 1a6:	66 0f       	add	r22, r22
 1a8:	77 1f       	adc	r23, r23
 1aa:	88 1f       	adc	r24, r24
 1ac:	99 1f       	adc	r25, r25
 1ae:	4a 95       	dec	r20
 1b0:	d1 f7       	brne	.-12     	; 0x1a6 <micros+0x3e>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:270
  //the high part gets divided by cCPuS then multiplied by the prescaler. Then take the low 8 bits plus the high part modulo-cCPuS to correct for the division, then multiply that by the prescaler value first before dividing by cCPuS, and finally add the two together.
  //return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + ((t+(((m<<8)%clockCyclesPerMicrosecond())) * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond()));
  return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + (t * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
#endif
#endif
}
 1b2:	08 95       	ret

000001b4 <delay>:
delay():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:280
  // Empty
}
void yield(void) __attribute__ ((weak, alias("__empty")));

void delay(unsigned long ms)
{
 1b4:	cf 92       	push	r12
 1b6:	df 92       	push	r13
 1b8:	ef 92       	push	r14
 1ba:	ff 92       	push	r15
 1bc:	cf 93       	push	r28
 1be:	df 93       	push	r29
 1c0:	6b 01       	movw	r12, r22
 1c2:	7c 01       	movw	r14, r24
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:282
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();
 1c4:	d1 df       	rcall	.-94     	; 0x168 <micros>
 1c6:	eb 01       	movw	r28, r22
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:286

  while (ms > 0) {
    yield();
    while (((uint16_t)micros() - start) >= 1000 && ms) {
 1c8:	cf df       	rcall	.-98     	; 0x168 <micros>
 1ca:	6c 1b       	sub	r22, r28
 1cc:	7d 0b       	sbc	r23, r29
 1ce:	68 3e       	cpi	r22, 0xE8	; 232
 1d0:	73 40       	sbci	r23, 0x03	; 3
 1d2:	a0 f0       	brcs	.+40     	; 0x1fc <delay+0x48>
 1d4:	c1 14       	cp	r12, r1
 1d6:	d1 04       	cpc	r13, r1
 1d8:	e1 04       	cpc	r14, r1
 1da:	f1 04       	cpc	r15, r1
 1dc:	39 f4       	brne	.+14     	; 0x1ec <delay+0x38>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:296
  #else
  uint32_t start = millis();
  while((millis() - start) < ms)  /* NOP */yield();
  return;
  #endif
}
 1de:	df 91       	pop	r29
 1e0:	cf 91       	pop	r28
 1e2:	ff 90       	pop	r15
 1e4:	ef 90       	pop	r14
 1e6:	df 90       	pop	r13
 1e8:	cf 90       	pop	r12
 1ea:	08 95       	ret
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:287
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
    yield();
    while (((uint16_t)micros() - start) >= 1000 && ms) {
      ms--;
 1ec:	81 e0       	ldi	r24, 0x01	; 1
 1ee:	c8 1a       	sub	r12, r24
 1f0:	d1 08       	sbc	r13, r1
 1f2:	e1 08       	sbc	r14, r1
 1f4:	f1 08       	sbc	r15, r1
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:288
      start += 1000;
 1f6:	c8 51       	subi	r28, 0x18	; 24
 1f8:	dc 4f       	sbci	r29, 0xFC	; 252
 1fa:	e6 cf       	rjmp	.-52     	; 0x1c8 <delay+0x14>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:284
void delay(unsigned long ms)
{
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
 1fc:	c1 14       	cp	r12, r1
 1fe:	d1 04       	cpc	r13, r1
 200:	e1 04       	cpc	r14, r1
 202:	f1 04       	cpc	r15, r1
 204:	09 f7       	brne	.-62     	; 0x1c8 <delay+0x14>
 206:	eb cf       	rjmp	.-42     	; 0x1de <delay+0x2a>

00000208 <millis>:
millis():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:176
}

unsigned long millis()
{
  unsigned long m;
  uint8_t oldSREG = SREG;
 208:	2f b7       	in	r18, 0x3f	; 63
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:180

  // disable interrupts while we read millis_timer_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
  cli();
 20a:	f8 94       	cli
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:181
  m = millis_timer_millis;
 20c:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <millis_timer_millis>
 210:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <millis_timer_millis+0x1>
 214:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <millis_timer_millis+0x2>
 218:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <millis_timer_millis+0x3>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:182
  SREG = oldSREG;
 21c:	2f bf       	out	0x3f, r18	; 63
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:185

  return m;
}
 21e:	08 95       	ret

00000220 <select_button_pressed()>:
_Z21select_button_pressedv():
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:16
  DDRA = 0x00;*/
  PORTA= PORTA & B01010000;//0x00;
  DDRA = DDRA & B01010000;//0x00;
  return state;
}
bool select_button_pressed(){
 220:	cf 93       	push	r28
 222:	df 93       	push	r29
 224:	1f 92       	push	r1
 226:	cd b7       	in	r28, 0x3d	; 61
 228:	de b7       	in	r29, 0x3e	; 62
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:17
  DDRA |= (0X01 << SELECT_PIN);
 22a:	d1 9a       	sbi	0x1a, 1	; 26
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:20
  //PORTA |= (0 << led_pins[0]);  //It should already be 0
  //DDRA |= (0x00
  PORTA |= (0x01 << BUTTONS); //Set PullUp Resistance in pin num 7 PORT A
 22c:	df 9a       	sbi	0x1b, 7	; 27
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:21
  __asm__ __volatile__ ("nop\n\t");
 22e:	00 00       	nop
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:23
  //__asm__("nop\n\t");
  volatile bool state = !((PINA >> BUTTONS)&0x01);//!digitalRead(BUTTONS);//!((PINA >> BUTTONS)&0x01);   //This seems to be provoking an undesired blink on the clock leds
 230:	89 b3       	in	r24, 0x19	; 25
 232:	80 95       	com	r24
 234:	88 1f       	adc	r24, r24
 236:	88 27       	eor	r24, r24
 238:	88 1f       	adc	r24, r24
 23a:	89 83       	std	Y+1, r24	; 0x01
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:26
  /*PORTA= 0x00;
  DDRA = 0x00;*/
  PORTA= PORTA & B01010000;//0x00;
 23c:	8b b3       	in	r24, 0x1b	; 27
 23e:	80 75       	andi	r24, 0x50	; 80
 240:	8b bb       	out	0x1b, r24	; 27
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:27
  DDRA = DDRA & B01010000;//0x00;
 242:	8a b3       	in	r24, 0x1a	; 26
 244:	80 75       	andi	r24, 0x50	; 80
 246:	8a bb       	out	0x1a, r24	; 26
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:28
  return state;
 248:	89 81       	ldd	r24, Y+1	; 0x01
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:29
}
 24a:	0f 90       	pop	r0
 24c:	df 91       	pop	r29
 24e:	cf 91       	pop	r28
 250:	08 95       	ret

00000252 <set_button_pressed()>:
_Z18set_button_pressedv():
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:2
bool set_button_pressed(){
  DDRA |= (0X01 << SET_PIN);
 252:	d0 9a       	sbi	0x1a, 0	; 26
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:6
  //PORTA |= (0 << led_pins[0]);  //It should already be 0
  //DDRA |= (0x00
  //PORTA |= (0x01 << BUTTONS); //Set PullUp Resistance in pin num 7 PORT A
  PORTB |=(0x01 << 2);    //PORT B PIN 2
 254:	c2 9a       	sbi	0x18, 2	; 24
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:7
  __asm__ __volatile__ ("nop\n\t");
 256:	00 00       	nop
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:9
  //bool state = !((PINA >> BUTTONS)&0x01);
  bool state = !((PINB >> 2)&0x01);
 258:	86 b3       	in	r24, 0x16	; 22
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:12
  /*PORTA= 0x00;
  DDRA = 0x00;*/
  PORTA= PORTA & B01010000;//0x00;
 25a:	9b b3       	in	r25, 0x1b	; 27
 25c:	90 75       	andi	r25, 0x50	; 80
 25e:	9b bb       	out	0x1b, r25	; 27
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:13
  DDRA = DDRA & B01010000;//0x00;
 260:	9a b3       	in	r25, 0x1a	; 26
 262:	90 75       	andi	r25, 0x50	; 80
 264:	9a bb       	out	0x1a, r25	; 26
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:9
  //DDRA |= (0x00
  //PORTA |= (0x01 << BUTTONS); //Set PullUp Resistance in pin num 7 PORT A
  PORTB |=(0x01 << 2);    //PORT B PIN 2
  __asm__ __volatile__ ("nop\n\t");
  //bool state = !((PINA >> BUTTONS)&0x01);
  bool state = !((PINB >> 2)&0x01);
 266:	82 fb       	bst	r24, 2
 268:	88 27       	eor	r24, r24
 26a:	80 f9       	bld	r24, 0
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:15
  /*PORTA= 0x00;
  DDRA = 0x00;*/
  PORTA= PORTA & B01010000;//0x00;
  DDRA = DDRA & B01010000;//0x00;
  return state;
}
 26c:	91 e0       	ldi	r25, 0x01	; 1
 26e:	89 27       	eor	r24, r25
 270:	08 95       	ret

00000272 <setPin(int, bool)>:
_Z6setPinib():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:49
  DS3231_init();
  //Rtc.Begin();
  DS3231_get_time(&time);
}
void setPin(int pin, bool state){
  DDRA |= (0X01 << pin);
 272:	9a b3       	in	r25, 0x1a	; 26
 274:	21 e0       	ldi	r18, 0x01	; 1
 276:	30 e0       	ldi	r19, 0x00	; 0
 278:	08 2e       	mov	r0, r24
 27a:	01 c0       	rjmp	.+2      	; 0x27e <setPin(int, bool)+0xc>
 27c:	22 0f       	add	r18, r18
 27e:	0a 94       	dec	r0
 280:	ea f7       	brpl	.-6      	; 0x27c <setPin(int, bool)+0xa>
 282:	92 2b       	or	r25, r18
 284:	9a bb       	out	0x1a, r25	; 26
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:50
  PORTA |= (state << pin);
 286:	9b b3       	in	r25, 0x1b	; 27
 288:	01 c0       	rjmp	.+2      	; 0x28c <setPin(int, bool)+0x1a>
 28a:	66 0f       	add	r22, r22
 28c:	8a 95       	dec	r24
 28e:	ea f7       	brpl	.-6      	; 0x28a <setPin(int, bool)+0x18>
 290:	69 2b       	or	r22, r25
 292:	6b bb       	out	0x1b, r22	; 27
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:51
}
 294:	08 95       	ret

00000296 <printHoras(unsigned char, int*, bool, bool)>:
_Z10printHorashPibb():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:52
void printHoras(byte numero, int* pines, bool not_minutes, bool horas){
 296:	2f 92       	push	r2
 298:	3f 92       	push	r3
 29a:	4f 92       	push	r4
 29c:	5f 92       	push	r5
 29e:	6f 92       	push	r6
 2a0:	7f 92       	push	r7
 2a2:	8f 92       	push	r8
 2a4:	9f 92       	push	r9
 2a6:	af 92       	push	r10
 2a8:	bf 92       	push	r11
 2aa:	cf 92       	push	r12
 2ac:	df 92       	push	r13
 2ae:	ef 92       	push	r14
 2b0:	ff 92       	push	r15
 2b2:	0f 93       	push	r16
 2b4:	1f 93       	push	r17
 2b6:	cf 93       	push	r28
 2b8:	df 93       	push	r29
 2ba:	00 d0       	rcall	.+0      	; 0x2bc <printHoras(unsigned char, int*, bool, bool)+0x26>
 2bc:	00 d0       	rcall	.+0      	; 0x2be <printHoras(unsigned char, int*, bool, bool)+0x28>
 2be:	00 d0       	rcall	.+0      	; 0x2c0 <printHoras(unsigned char, int*, bool, bool)+0x2a>
 2c0:	1f 92       	push	r1
 2c2:	cd b7       	in	r28, 0x3d	; 61
 2c4:	de b7       	in	r29, 0x3e	; 62
 2c6:	7b 01       	movw	r14, r22
 2c8:	4a 83       	std	Y+2, r20	; 0x02
 2ca:	29 83       	std	Y+1, r18	; 0x01
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:54
  //El booleano not_minutes se usa en el 3 led del segundo segmento, para determinar que lado de los 2 es (Minutos o segundos)
  byte primer_digito = numero & 0x0F;//numero%10; //Guardamos el primer digito
 2cc:	98 2f       	mov	r25, r24
 2ce:	9f 70       	andi	r25, 0x0F	; 15
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:55
  byte segundo_digito = (numero>>4)&0x0F;//numero/10;//Guardamos el segundo digito
 2d0:	82 95       	swap	r24
 2d2:	8f 70       	andi	r24, 0x0F	; 15
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:57
  int length = 5;//(sizeof(pines)/sizeof(pines[0]))-1;//5;//sizeof(pines);
  if(horas) length=2;
 2d4:	21 11       	cpse	r18, r1
 2d6:	d4 c0       	rjmp	.+424    	; 0x480 <__LOCK_REGION_LENGTH__+0x80>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:56
}
void printHoras(byte numero, int* pines, bool not_minutes, bool horas){
  //El booleano not_minutes se usa en el 3 led del segundo segmento, para determinar que lado de los 2 es (Minutos o segundos)
  byte primer_digito = numero & 0x0F;//numero%10; //Guardamos el primer digito
  byte segundo_digito = (numero>>4)&0x0F;//numero/10;//Guardamos el segundo digito
  int length = 5;//(sizeof(pines)/sizeof(pines[0]))-1;//5;//sizeof(pines);
 2d8:	25 e0       	ldi	r18, 0x05	; 5
 2da:	30 e0       	ldi	r19, 0x00	; 0
 2dc:	3c 83       	std	Y+4, r19	; 0x04
 2de:	2b 83       	std	Y+3, r18	; 0x03
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:60
  if(horas) length=2;
  for(int i=0; i<4; i++){
    if((primer_digito>>i)&0x01){
      pinMode(pines[length], OUTPUT); //Lo pongo en en OUTPUT, porque esta seccion del segmento sera la que manejemos prmero.
 2e0:	eb 81       	ldd	r30, Y+3	; 0x03
 2e2:	fc 81       	ldd	r31, Y+4	; 0x04
 2e4:	ee 0f       	add	r30, r30
 2e6:	ff 1f       	adc	r31, r31
 2e8:	ff 83       	std	Y+7, r31	; 0x07
 2ea:	ee 83       	std	Y+6, r30	; 0x06
 2ec:	3f 01       	movw	r6, r30
 2ee:	6e 0c       	add	r6, r14
 2f0:	7f 1c       	adc	r7, r15
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:83
        case 2:
          /*digitalWrite(pines[length], HIGH);
          pinMode(pines[length-2], OUTPUT);
          digitalWrite(pines[length-2], LOW);*/
          setPin(pines[length], 1);
          setPin(pines[length-2], 0);
 2f2:	4f 01       	movw	r8, r30
 2f4:	f4 e0       	ldi	r31, 0x04	; 4
 2f6:	8f 1a       	sub	r8, r31
 2f8:	91 08       	sbc	r9, r1
 2fa:	8e 0c       	add	r8, r14
 2fc:	9f 1c       	adc	r9, r15
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:76
        case 1:
          /*digitalWrite(pines[length], LOW);
          pinMode(pines[length-1], OUTPUT);
          digitalWrite(pines[length-1], HIGH);*/
          setPin(pines[length], 0);
          setPin(pines[length-1], 1);
 2fe:	ae 80       	ldd	r10, Y+6	; 0x06
 300:	bf 80       	ldd	r11, Y+7	; 0x07
 302:	22 e0       	ldi	r18, 0x02	; 2
 304:	a2 1a       	sub	r10, r18
 306:	b1 08       	sbc	r11, r1
 308:	ae 0c       	add	r10, r14
 30a:	bf 1c       	adc	r11, r15
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:141
        case 2:
          /*pinMode(pines[length-4], OUTPUT);
          pinMode(pines[length-5], OUTPUT);
          digitalWrite(pines[length-4], not_minutes);
          digitalWrite(pines[length-5], !not_minutes);*/
          setPin(pines[length-4], not_minutes);
 30c:	ce 80       	ldd	r12, Y+6	; 0x06
 30e:	df 80       	ldd	r13, Y+7	; 0x07
 310:	38 e0       	ldi	r19, 0x08	; 8
 312:	c3 1a       	sub	r12, r19
 314:	d1 08       	sbc	r13, r1
 316:	ce 0c       	add	r12, r14
 318:	df 1c       	adc	r13, r15
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:142
          setPin(pines[length-5], !not_minutes);
 31a:	2e 81       	ldd	r18, Y+6	; 0x06
 31c:	3f 81       	ldd	r19, Y+7	; 0x07
 31e:	2a 50       	subi	r18, 0x0A	; 10
 320:	31 09       	sbc	r19, r1
 322:	a7 01       	movw	r20, r14
 324:	42 0f       	add	r20, r18
 326:	53 1f       	adc	r21, r19
 328:	5c 83       	std	Y+4, r21	; 0x04
 32a:	4b 83       	std	Y+3, r20	; 0x03
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:132
          else{
            /*pinMode(pines[length-3], OUTPUT);
            pinMode(pines[length-4], OUTPUT);
            digitalWrite(pines[length-3], HIGH);
            digitalWrite(pines[length-4], LOW);*/
            setPin(pines[length-3], 1);
 32c:	ee 81       	ldd	r30, Y+6	; 0x06
 32e:	ff 81       	ldd	r31, Y+7	; 0x07
 330:	36 97       	sbiw	r30, 0x06	; 6
 332:	ee 0d       	add	r30, r14
 334:	ff 1d       	adc	r31, r15
 336:	ff 83       	std	Y+7, r31	; 0x07
 338:	ee 83       	std	Y+6, r30	; 0x06
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:58
  //El booleano not_minutes se usa en el 3 led del segundo segmento, para determinar que lado de los 2 es (Minutos o segundos)
  byte primer_digito = numero & 0x0F;//numero%10; //Guardamos el primer digito
  byte segundo_digito = (numero>>4)&0x0F;//numero/10;//Guardamos el segundo digito
  int length = 5;//(sizeof(pines)/sizeof(pines[0]))-1;//5;//sizeof(pines);
  if(horas) length=2;
  for(int i=0; i<4; i++){
 33a:	10 e0       	ldi	r17, 0x00	; 0
 33c:	00 e0       	ldi	r16, 0x00	; 0
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:59
    if((primer_digito>>i)&0x01){
 33e:	29 2e       	mov	r2, r25
 340:	31 2c       	mov	r3, r1
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:98
      delay(1);
      PORTA= PORTA & B01010000;//0x00;
      DDRA = DDRA & B01010000;//0x00;
      
    }
    if((segundo_digito>>i)&0x01){
 342:	48 2e       	mov	r4, r24
 344:	51 2c       	mov	r5, r1
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:142
          /*pinMode(pines[length-4], OUTPUT);
          pinMode(pines[length-5], OUTPUT);
          digitalWrite(pines[length-4], not_minutes);
          digitalWrite(pines[length-5], !not_minutes);*/
          setPin(pines[length-4], not_minutes);
          setPin(pines[length-5], !not_minutes);
 346:	81 e0       	ldi	r24, 0x01	; 1
 348:	fa 81       	ldd	r31, Y+2	; 0x02
 34a:	f8 27       	eor	r31, r24
 34c:	fd 83       	std	Y+5, r31	; 0x05
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:59
  byte primer_digito = numero & 0x0F;//numero%10; //Guardamos el primer digito
  byte segundo_digito = (numero>>4)&0x0F;//numero/10;//Guardamos el segundo digito
  int length = 5;//(sizeof(pines)/sizeof(pines[0]))-1;//5;//sizeof(pines);
  if(horas) length=2;
  for(int i=0; i<4; i++){
    if((primer_digito>>i)&0x01){
 34e:	c1 01       	movw	r24, r2
 350:	00 2e       	mov	r0, r16
 352:	02 c0       	rjmp	.+4      	; 0x358 <printHoras(unsigned char, int*, bool, bool)+0xc2>
 354:	95 95       	asr	r25
 356:	87 95       	ror	r24
 358:	0a 94       	dec	r0
 35a:	e2 f7       	brpl	.-8      	; 0x354 <printHoras(unsigned char, int*, bool, bool)+0xbe>
 35c:	80 ff       	sbrs	r24, 0
 35e:	44 c0       	rjmp	.+136    	; 0x3e8 <printHoras(unsigned char, int*, bool, bool)+0x152>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:60
      pinMode(pines[length], OUTPUT); //Lo pongo en en OUTPUT, porque esta seccion del segmento sera la que manejemos prmero.
 360:	f3 01       	movw	r30, r6
 362:	80 81       	ld	r24, Z
pinMode():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:34
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
 364:	87 fd       	sbrc	r24, 7
 366:	8f 77       	andi	r24, 0x7F	; 127
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:35
  uint8_t bit = digitalPinToBitMask(pin);
 368:	90 e0       	ldi	r25, 0x00	; 0
 36a:	fc 01       	movw	r30, r24
 36c:	e0 5c       	subi	r30, 0xC0	; 192
 36e:	ff 4f       	sbci	r31, 0xFF	; 255
 370:	24 91       	lpm	r18, Z
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:36
  uint8_t port = digitalPinToPort(pin);
 372:	fc 01       	movw	r30, r24
 374:	ec 5c       	subi	r30, 0xCC	; 204
 376:	ff 4f       	sbci	r31, 0xFF	; 255
 378:	e4 91       	lpm	r30, Z
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:39
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
 37a:	ee 23       	and	r30, r30
 37c:	a1 f0       	breq	.+40     	; 0x3a6 <printHoras(unsigned char, int*, bool, bool)+0x110>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:41

  reg = portModeRegister(port);
 37e:	8e 2f       	mov	r24, r30
 380:	90 e0       	ldi	r25, 0x00	; 0
 382:	88 0f       	add	r24, r24
 384:	99 1f       	adc	r25, r25
 386:	fc 01       	movw	r30, r24
 388:	e8 5d       	subi	r30, 0xD8	; 216
 38a:	ff 4f       	sbci	r31, 0xFF	; 255
 38c:	a5 91       	lpm	r26, Z+
 38e:	b4 91       	lpm	r27, Z
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:42
  out = portOutputRegister(port);
 390:	fc 01       	movw	r30, r24
 392:	ee 5d       	subi	r30, 0xDE	; 222
 394:	ff 4f       	sbci	r31, 0xFF	; 255
 396:	85 91       	lpm	r24, Z+
 398:	94 91       	lpm	r25, Z
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:57
                cli();
    *reg &= ~bit;
    *out |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 39a:	8f b7       	in	r24, 0x3f	; 63
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:58
                cli();
 39c:	f8 94       	cli
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:59
    *reg |= bit;
 39e:	ec 91       	ld	r30, X
 3a0:	2e 2b       	or	r18, r30
 3a2:	2c 93       	st	X, r18
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:60
    SREG = oldSREG;
 3a4:	8f bf       	out	0x3f, r24	; 63
 3a6:	f3 01       	movw	r30, r6
 3a8:	80 81       	ld	r24, Z
 3aa:	91 81       	ldd	r25, Z+1	; 0x01
_Z10printHorashPibb():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:63
      //Estos son los casos para la primera parte del segmento, que esta controlada por la ultima patilla en el array
      ////Serial.println(String("Comprobacion Realizada Bit numero: ")+i+String("Byte: ")+ primer_digito);
      switch(i){
 3ac:	02 30       	cpi	r16, 0x02	; 2
 3ae:	11 05       	cpc	r17, r1
 3b0:	09 f4       	brne	.+2      	; 0x3b4 <printHoras(unsigned char, int*, bool, bool)+0x11e>
 3b2:	6f c0       	rjmp	.+222    	; 0x492 <__LOCK_REGION_LENGTH__+0x92>
 3b4:	03 30       	cpi	r16, 0x03	; 3
 3b6:	11 05       	cpc	r17, r1
 3b8:	09 f4       	brne	.+2      	; 0x3bc <printHoras(unsigned char, int*, bool, bool)+0x126>
 3ba:	70 c0       	rjmp	.+224    	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
 3bc:	01 30       	cpi	r16, 0x01	; 1
 3be:	11 05       	cpc	r17, r1
 3c0:	09 f4       	brne	.+2      	; 0x3c4 <printHoras(unsigned char, int*, bool, bool)+0x12e>
 3c2:	63 c0       	rjmp	.+198    	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:68
        case 0:
          /*digitalWrite(pines[length], HIGH);
          pinMode(pines[length-1], OUTPUT);
          digitalWrite(pines[length-1], LOW);*/
          setPin(pines[length], 1);
 3c4:	61 e0       	ldi	r22, 0x01	; 1
 3c6:	55 df       	rcall	.-342    	; 0x272 <setPin(int, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:69
          setPin(pines[length-1], 0);
 3c8:	60 e0       	ldi	r22, 0x00	; 0
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:76
        case 1:
          /*digitalWrite(pines[length], LOW);
          pinMode(pines[length-1], OUTPUT);
          digitalWrite(pines[length-1], HIGH);*/
          setPin(pines[length], 0);
          setPin(pines[length-1], 1);
 3ca:	f5 01       	movw	r30, r10
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:90
        case 3:
          /*digitalWrite(pines[length], LOW);
          pinMode(pines[length-2], OUTPUT);
          digitalWrite(pines[length-2], HIGH);*/
          setPin(pines[length], 0);
          setPin(pines[length-2], 1);
 3cc:	80 81       	ld	r24, Z
 3ce:	91 81       	ldd	r25, Z+1	; 0x01
 3d0:	50 df       	rcall	.-352    	; 0x272 <setPin(int, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:93
          break;
      }
      delay(1);
 3d2:	61 e0       	ldi	r22, 0x01	; 1
 3d4:	70 e0       	ldi	r23, 0x00	; 0
 3d6:	80 e0       	ldi	r24, 0x00	; 0
 3d8:	90 e0       	ldi	r25, 0x00	; 0
 3da:	ec de       	rcall	.-552    	; 0x1b4 <delay>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:94
      PORTA= PORTA & B01010000;//0x00;
 3dc:	8b b3       	in	r24, 0x1b	; 27
 3de:	80 75       	andi	r24, 0x50	; 80
 3e0:	8b bb       	out	0x1b, r24	; 27
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:95
      DDRA = DDRA & B01010000;//0x00;
 3e2:	8a b3       	in	r24, 0x1a	; 26
 3e4:	80 75       	andi	r24, 0x50	; 80
 3e6:	8a bb       	out	0x1a, r24	; 26
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:98
      
    }
    if((segundo_digito>>i)&0x01){
 3e8:	c2 01       	movw	r24, r4
 3ea:	00 2e       	mov	r0, r16
 3ec:	02 c0       	rjmp	.+4      	; 0x3f2 <printHoras(unsigned char, int*, bool, bool)+0x15c>
 3ee:	95 95       	asr	r25
 3f0:	87 95       	ror	r24
 3f2:	0a 94       	dec	r0
 3f4:	e2 f7       	brpl	.-8      	; 0x3ee <printHoras(unsigned char, int*, bool, bool)+0x158>
 3f6:	80 ff       	sbrs	r24, 0
 3f8:	24 c0       	rjmp	.+72     	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:100
      ////Serial.println(String("Comprobacion Realizada Bit numero: ")+i+String("Byte: ")+ segundo_digito);
      switch(i){
 3fa:	01 30       	cpi	r16, 0x01	; 1
 3fc:	11 05       	cpc	r17, r1
 3fe:	09 f4       	brne	.+2      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
 400:	5c c0       	rjmp	.+184    	; 0x4ba <__LOCK_REGION_LENGTH__+0xba>
 402:	02 30       	cpi	r16, 0x02	; 2
 404:	11 05       	cpc	r17, r1
 406:	09 f4       	brne	.+2      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
 408:	6a c0       	rjmp	.+212    	; 0x4de <__LOCK_REGION_LENGTH__+0xde>
 40a:	01 15       	cp	r16, r1
 40c:	11 05       	cpc	r17, r1
 40e:	71 f4       	brne	.+28     	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:102
        case 0:
          if(horas){
 410:	f9 81       	ldd	r31, Y+1	; 0x01
 412:	ff 23       	and	r31, r31
 414:	09 f4       	brne	.+2      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
 416:	46 c0       	rjmp	.+140    	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:107
            //pinMode(pines[0], OUTPUT);
            //pinMode(pines[1], OUTPUT);
            //digitalWrite(pines[0], HIGH);
            //digitalWrite(pines[1], LOW);
            setPin(pines[0], 1);
 418:	61 e0       	ldi	r22, 0x01	; 1
 41a:	f7 01       	movw	r30, r14
 41c:	80 81       	ld	r24, Z
 41e:	91 81       	ldd	r25, Z+1	; 0x01
 420:	28 df       	rcall	.-432    	; 0x272 <setPin(int, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:108
            setPin(pines[1], 0);
 422:	60 e0       	ldi	r22, 0x00	; 0
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:125
            /*pinMode(pines[0], OUTPUT);
            pinMode(pines[1], OUTPUT);
            digitalWrite(pines[0], LOW);
            digitalWrite(pines[1], HIGH);*/
            setPin(pines[0], 0);
            setPin(pines[1], 1);
 424:	f7 01       	movw	r30, r14
 426:	82 81       	ldd	r24, Z+2	; 0x02
 428:	93 81       	ldd	r25, Z+3	; 0x03
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:142
          /*pinMode(pines[length-4], OUTPUT);
          pinMode(pines[length-5], OUTPUT);
          digitalWrite(pines[length-4], not_minutes);
          digitalWrite(pines[length-5], !not_minutes);*/
          setPin(pines[length-4], not_minutes);
          setPin(pines[length-5], !not_minutes);
 42a:	23 df       	rcall	.-442    	; 0x272 <setPin(int, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:145
          break;
      }
      delay(1);
 42c:	61 e0       	ldi	r22, 0x01	; 1
 42e:	70 e0       	ldi	r23, 0x00	; 0
 430:	80 e0       	ldi	r24, 0x00	; 0
 432:	90 e0       	ldi	r25, 0x00	; 0
 434:	bf de       	rcall	.-642    	; 0x1b4 <delay>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:146
      PORTA= PORTA & B01010000;//0x00;
 436:	8b b3       	in	r24, 0x1b	; 27
 438:	80 75       	andi	r24, 0x50	; 80
 43a:	8b bb       	out	0x1b, r24	; 27
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:147
      DDRA = DDRA & B01010000;//0x00; //Excluimos los pines de I2C
 43c:	8a b3       	in	r24, 0x1a	; 26
 43e:	80 75       	andi	r24, 0x50	; 80
 440:	8a bb       	out	0x1a, r24	; 26
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:58
  //El booleano not_minutes se usa en el 3 led del segundo segmento, para determinar que lado de los 2 es (Minutos o segundos)
  byte primer_digito = numero & 0x0F;//numero%10; //Guardamos el primer digito
  byte segundo_digito = (numero>>4)&0x0F;//numero/10;//Guardamos el segundo digito
  int length = 5;//(sizeof(pines)/sizeof(pines[0]))-1;//5;//sizeof(pines);
  if(horas) length=2;
  for(int i=0; i<4; i++){
 442:	0f 5f       	subi	r16, 0xFF	; 255
 444:	1f 4f       	sbci	r17, 0xFF	; 255
 446:	04 30       	cpi	r16, 0x04	; 4
 448:	11 05       	cpc	r17, r1
 44a:	09 f0       	breq	.+2      	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
 44c:	80 cf       	rjmp	.-256    	; 0x34e <printHoras(unsigned char, int*, bool, bool)+0xb8>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:151
      PORTA= PORTA & B01010000;//0x00;
      DDRA = DDRA & B01010000;//0x00; //Excluimos los pines de I2C
    }

  }
}
 44e:	27 96       	adiw	r28, 0x07	; 7
 450:	0f b6       	in	r0, 0x3f	; 63
 452:	f8 94       	cli
 454:	de bf       	out	0x3e, r29	; 62
 456:	0f be       	out	0x3f, r0	; 63
 458:	cd bf       	out	0x3d, r28	; 61
 45a:	df 91       	pop	r29
 45c:	cf 91       	pop	r28
 45e:	1f 91       	pop	r17
 460:	0f 91       	pop	r16
 462:	ff 90       	pop	r15
 464:	ef 90       	pop	r14
 466:	df 90       	pop	r13
 468:	cf 90       	pop	r12
 46a:	bf 90       	pop	r11
 46c:	af 90       	pop	r10
 46e:	9f 90       	pop	r9
 470:	8f 90       	pop	r8
 472:	7f 90       	pop	r7
 474:	6f 90       	pop	r6
 476:	5f 90       	pop	r5
 478:	4f 90       	pop	r4
 47a:	3f 90       	pop	r3
 47c:	2f 90       	pop	r2
 47e:	08 95       	ret
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:57
void printHoras(byte numero, int* pines, bool not_minutes, bool horas){
  //El booleano not_minutes se usa en el 3 led del segundo segmento, para determinar que lado de los 2 es (Minutos o segundos)
  byte primer_digito = numero & 0x0F;//numero%10; //Guardamos el primer digito
  byte segundo_digito = (numero>>4)&0x0F;//numero/10;//Guardamos el segundo digito
  int length = 5;//(sizeof(pines)/sizeof(pines[0]))-1;//5;//sizeof(pines);
  if(horas) length=2;
 480:	42 e0       	ldi	r20, 0x02	; 2
 482:	50 e0       	ldi	r21, 0x00	; 0
 484:	5c 83       	std	Y+4, r21	; 0x04
 486:	4b 83       	std	Y+3, r20	; 0x03
 488:	2b cf       	rjmp	.-426    	; 0x2e0 <printHoras(unsigned char, int*, bool, bool)+0x4a>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:75
          break;
        case 1:
          /*digitalWrite(pines[length], LOW);
          pinMode(pines[length-1], OUTPUT);
          digitalWrite(pines[length-1], HIGH);*/
          setPin(pines[length], 0);
 48a:	60 e0       	ldi	r22, 0x00	; 0
 48c:	f2 de       	rcall	.-540    	; 0x272 <setPin(int, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:76
          setPin(pines[length-1], 1);
 48e:	61 e0       	ldi	r22, 0x01	; 1
 490:	9c cf       	rjmp	.-200    	; 0x3ca <printHoras(unsigned char, int*, bool, bool)+0x134>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:82
          break;
        case 2:
          /*digitalWrite(pines[length], HIGH);
          pinMode(pines[length-2], OUTPUT);
          digitalWrite(pines[length-2], LOW);*/
          setPin(pines[length], 1);
 492:	61 e0       	ldi	r22, 0x01	; 1
 494:	ee de       	rcall	.-548    	; 0x272 <setPin(int, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:83
          setPin(pines[length-2], 0);
 496:	60 e0       	ldi	r22, 0x00	; 0
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:90
        case 3:
          /*digitalWrite(pines[length], LOW);
          pinMode(pines[length-2], OUTPUT);
          digitalWrite(pines[length-2], HIGH);*/
          setPin(pines[length], 0);
          setPin(pines[length-2], 1);
 498:	f4 01       	movw	r30, r8
 49a:	98 cf       	rjmp	.-208    	; 0x3cc <printHoras(unsigned char, int*, bool, bool)+0x136>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:89
          break;
        case 3:
          /*digitalWrite(pines[length], LOW);
          pinMode(pines[length-2], OUTPUT);
          digitalWrite(pines[length-2], HIGH);*/
          setPin(pines[length], 0);
 49c:	60 e0       	ldi	r22, 0x00	; 0
 49e:	e9 de       	rcall	.-558    	; 0x272 <setPin(int, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:90
          setPin(pines[length-2], 1);
 4a0:	61 e0       	ldi	r22, 0x01	; 1
 4a2:	fa cf       	rjmp	.-12     	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:114
          }else{
            /*pinMode(pines[length-3], OUTPUT);
            pinMode(pines[length-4], OUTPUT);
            digitalWrite(pines[length-3], LOW);
            digitalWrite(pines[length-4], HIGH);*/
            setPin(pines[length-3], 0);
 4a4:	60 e0       	ldi	r22, 0x00	; 0
 4a6:	ee 81       	ldd	r30, Y+6	; 0x06
 4a8:	ff 81       	ldd	r31, Y+7	; 0x07
 4aa:	80 81       	ld	r24, Z
 4ac:	91 81       	ldd	r25, Z+1	; 0x01
 4ae:	e1 de       	rcall	.-574    	; 0x272 <setPin(int, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:115
            setPin(pines[length-4], 1);
 4b0:	61 e0       	ldi	r22, 0x01	; 1
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:133
            /*pinMode(pines[length-3], OUTPUT);
            pinMode(pines[length-4], OUTPUT);
            digitalWrite(pines[length-3], HIGH);
            digitalWrite(pines[length-4], LOW);*/
            setPin(pines[length-3], 1);
            setPin(pines[length-4], 0);
 4b2:	f6 01       	movw	r30, r12
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:142
          /*pinMode(pines[length-4], OUTPUT);
          pinMode(pines[length-5], OUTPUT);
          digitalWrite(pines[length-4], not_minutes);
          digitalWrite(pines[length-5], !not_minutes);*/
          setPin(pines[length-4], not_minutes);
          setPin(pines[length-5], !not_minutes);
 4b4:	80 81       	ld	r24, Z
 4b6:	91 81       	ldd	r25, Z+1	; 0x01
 4b8:	b8 cf       	rjmp	.-144    	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:119
            setPin(pines[length-3], 0);
            setPin(pines[length-4], 1);
          }
          break;
        case 1:
          if(horas){
 4ba:	f9 81       	ldd	r31, Y+1	; 0x01
 4bc:	ff 23       	and	r31, r31
 4be:	39 f0       	breq	.+14     	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:124
            /*pinMode(pines[0], OUTPUT);
            pinMode(pines[1], OUTPUT);
            digitalWrite(pines[0], LOW);
            digitalWrite(pines[1], HIGH);*/
            setPin(pines[0], 0);
 4c0:	60 e0       	ldi	r22, 0x00	; 0
 4c2:	f7 01       	movw	r30, r14
 4c4:	80 81       	ld	r24, Z
 4c6:	91 81       	ldd	r25, Z+1	; 0x01
 4c8:	d4 de       	rcall	.-600    	; 0x272 <setPin(int, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:125
            setPin(pines[1], 1);
 4ca:	61 e0       	ldi	r22, 0x01	; 1
 4cc:	ab cf       	rjmp	.-170    	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:132
          else{
            /*pinMode(pines[length-3], OUTPUT);
            pinMode(pines[length-4], OUTPUT);
            digitalWrite(pines[length-3], HIGH);
            digitalWrite(pines[length-4], LOW);*/
            setPin(pines[length-3], 1);
 4ce:	61 e0       	ldi	r22, 0x01	; 1
 4d0:	ee 81       	ldd	r30, Y+6	; 0x06
 4d2:	ff 81       	ldd	r31, Y+7	; 0x07
 4d4:	80 81       	ld	r24, Z
 4d6:	91 81       	ldd	r25, Z+1	; 0x01
 4d8:	cc de       	rcall	.-616    	; 0x272 <setPin(int, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:133
            setPin(pines[length-4], 0);
 4da:	60 e0       	ldi	r22, 0x00	; 0
 4dc:	ea cf       	rjmp	.-44     	; 0x4b2 <__LOCK_REGION_LENGTH__+0xb2>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:141
        case 2:
          /*pinMode(pines[length-4], OUTPUT);
          pinMode(pines[length-5], OUTPUT);
          digitalWrite(pines[length-4], not_minutes);
          digitalWrite(pines[length-5], !not_minutes);*/
          setPin(pines[length-4], not_minutes);
 4de:	6a 81       	ldd	r22, Y+2	; 0x02
 4e0:	f6 01       	movw	r30, r12
 4e2:	80 81       	ld	r24, Z
 4e4:	91 81       	ldd	r25, Z+1	; 0x01
 4e6:	c5 de       	rcall	.-630    	; 0x272 <setPin(int, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:142
          setPin(pines[length-5], !not_minutes);
 4e8:	6d 81       	ldd	r22, Y+5	; 0x05
 4ea:	eb 81       	ldd	r30, Y+3	; 0x03
 4ec:	fc 81       	ldd	r31, Y+4	; 0x04
 4ee:	e2 cf       	rjmp	.-60     	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>

000004f0 <USI_TWI_Master_Transfer>:
USI_TWI_Master_Transfer():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:223
 Data to be sent has to be placed into the USIDR prior to calling
 this function. Data read, will be return'ed from the function.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Transfer(unsigned char temp)
{
	USISR = temp;                                          // Set USISR according to temp.
 4f0:	8e b9       	out	0x0e, r24	; 14
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:231
	       (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
	       (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software clock strobe as source.
	       (1 << USITC);                                   // Toggle Clock Port.
	do {
		DELAY_T2TWI;
		USICR = temp; // Generate positve SCL edge.
 4f2:	8b e2       	ldi	r24, 0x2B	; 43
_delay_us():
/home/lukilukeskywalker/.arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino5/avr/include/util/delay.h:276
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4f4:	9e e0       	ldi	r25, 0x0E	; 14
 4f6:	9a 95       	dec	r25
 4f8:	f1 f7       	brne	.-4      	; 0x4f6 <USI_TWI_Master_Transfer+0x6>
USI_TWI_Master_Transfer():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:231
 4fa:	8d b9       	out	0x0d, r24	; 13
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:232
		while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 4fc:	cc 9b       	sbis	0x19, 4	; 25
 4fe:	fe cf       	rjmp	.-4      	; 0x4fc <USI_TWI_Master_Transfer+0xc>
_delay_us():
/home/lukilukeskywalker/.arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino5/avr/include/util/delay.h:276
 500:	96 e0       	ldi	r25, 0x06	; 6
 502:	9a 95       	dec	r25
 504:	f1 f7       	brne	.-4      	; 0x502 <USI_TWI_Master_Transfer+0x12>
 506:	00 c0       	rjmp	.+0      	; 0x508 <USI_TWI_Master_Transfer+0x18>
USI_TWI_Master_Transfer():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:235
			; // Wait for SCL to go high.
		DELAY_T4TWI;
		USICR = temp;                   // Generate negative SCL edge.
 508:	8d b9       	out	0x0d, r24	; 13
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:236
	} while (!(USISR & (1 << USIOIF))); // Check for transfer complete.
 50a:	76 9b       	sbis	0x0e, 6	; 14
 50c:	f3 cf       	rjmp	.-26     	; 0x4f4 <USI_TWI_Master_Transfer+0x4>
_delay_us():
/home/lukilukeskywalker/.arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino5/avr/include/util/delay.h:276
 50e:	8e e0       	ldi	r24, 0x0E	; 14
 510:	8a 95       	dec	r24
 512:	f1 f7       	brne	.-4      	; 0x510 <USI_TWI_Master_Transfer+0x20>
USI_TWI_Master_Transfer():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:239

	DELAY_T2TWI;
	temp  = USIDR;                 // Read out data.
 514:	8f b1       	in	r24, 0x0f	; 15
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:240
	USIDR = 0xFF;                  // Release SDA.
 516:	9f ef       	ldi	r25, 0xFF	; 255
 518:	9f b9       	out	0x0f, r25	; 15
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:241
	DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
 51a:	d6 9a       	sbi	0x1a, 6	; 26
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:244

	return temp; // Return the data from the USIDR
}
 51c:	08 95       	ret

0000051e <USI_TWI_Start_Transceiver_With_Data_Stop>:
USI_TWI_Start_Transceiver_With_Data_Stop():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:103
#ifndef __GNUC__
__x // AVR compiler
#endif
    unsigned char
    USI_TWI_Start_Transceiver_With_Data_Stop(unsigned char *msg, unsigned char msgSize, unsigned char stop)
{
 51e:	ff 92       	push	r15
 520:	0f 93       	push	r16
 522:	1f 93       	push	r17
 524:	cf 93       	push	r28
 526:	df 93       	push	r29
 528:	06 2f       	mov	r16, r22
 52a:	14 2f       	mov	r17, r20
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:111
	                               (0x0 << USICNT0); // set USI to shift 8 bits i.e. count 16 clock edges.
	unsigned char tempUSISR_1bit = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC)
	                               |                 // Prepare register value to: Clear flags, and
	                               (0xE << USICNT0); // set USI to shift 1 bit i.e. count 2 clock edges.

	USI_TWI_state.errorState  = 0;
 52c:	21 e0       	ldi	r18, 0x01	; 1
 52e:	20 93 b1 00 	sts	0x00B1, r18	; 0x8000b1 <USI_TWI_state>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:142
		USI_TWI_state.errorState = USI_TWI_UE_DATA_COL;
		return (FALSE);
	}
#endif

	if (!(*msg
 532:	fc 01       	movw	r30, r24
 534:	20 81       	ld	r18, Z
 536:	20 fd       	sbrc	r18, 0
 538:	03 c0       	rjmp	.+6      	; 0x540 <USI_TWI_Start_Transceiver_With_Data_Stop+0x22>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:145
	      & (1 << TWI_READ_BIT))) // The LSB in the address byte determines if is a masterRead or masterWrite operation.
	{
		USI_TWI_state.masterWriteDataMode = TRUE;
 53a:	23 e0       	ldi	r18, 0x03	; 3
 53c:	20 93 b1 00 	sts	0x00B1, r18	; 0x8000b1 <USI_TWI_state>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:149
	}

	/* Release SCL to ensure that (repeated) Start can be performed */
	PORT_USI_CL |= (1 << PIN_USI_SCL); // Release SCL.
 540:	dc 9a       	sbi	0x1b, 4	; 27
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:150
	while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 542:	cc 9b       	sbis	0x19, 4	; 25
 544:	fe cf       	rjmp	.-4      	; 0x542 <USI_TWI_Start_Transceiver_With_Data_Stop+0x24>
_delay_us():
/home/lukilukeskywalker/.arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino5/avr/include/util/delay.h:276
 546:	f6 e0       	ldi	r31, 0x06	; 6
 548:	fa 95       	dec	r31
 54a:	f1 f7       	brne	.-4      	; 0x548 <USI_TWI_Start_Transceiver_With_Data_Stop+0x2a>
 54c:	00 c0       	rjmp	.+0      	; 0x54e <USI_TWI_Start_Transceiver_With_Data_Stop+0x30>
USI_TWI_Start_Transceiver_With_Data_Stop():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:159
#else
	DELAY_T2TWI; // Delay for T2TWI if TWI_STANDARD_MODE
#endif

	/* Generate Start Condition */
	PORT_USI &= ~(1 << PIN_USI_SDA); // Force SDA LOW.
 54e:	de 98       	cbi	0x1b, 6	; 27
_delay_us():
/home/lukilukeskywalker/.arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino5/avr/include/util/delay.h:276
 550:	26 e0       	ldi	r18, 0x06	; 6
 552:	2a 95       	dec	r18
 554:	f1 f7       	brne	.-4      	; 0x552 <USI_TWI_Start_Transceiver_With_Data_Stop+0x34>
 556:	00 c0       	rjmp	.+0      	; 0x558 <USI_TWI_Start_Transceiver_With_Data_Stop+0x3a>
USI_TWI_Start_Transceiver_With_Data_Stop():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:161
	DELAY_T4TWI;
	PORT_USI_CL &= ~(1 << PIN_USI_SCL); // Pull SCL LOW.
 558:	dc 98       	cbi	0x1b, 4	; 27
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:162
	PORT_USI |= (1 << PIN_USI_SDA);  // Release SDA.
 55a:	de 9a       	sbi	0x1b, 6	; 27
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:165

#ifdef SIGNAL_VERIFY
	if (!(USISR & (1 << USISIF))) {
 55c:	77 99       	sbic	0x0e, 7	; 14
 55e:	0b c0       	rjmp	.+22     	; 0x576 <USI_TWI_Start_Transceiver_With_Data_Stop+0x58>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:166
		USI_TWI_state.errorState = USI_TWI_MISSING_START_CON;
 560:	87 e0       	ldi	r24, 0x07	; 7
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:184

			/* Clock and verify (N)ACK from slave */
			DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
			if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
				if (USI_TWI_state.addressMode)
					USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 562:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <USI_TWI_state>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:187
				else
					USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
				return (FALSE);
 566:	10 e0       	ldi	r17, 0x00	; 0
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:214
		USI_TWI_Master_Stop(); // Send a STOP condition on the TWI bus.
	}

	/* Transmission successfully completed*/
	return (TRUE);
}
 568:	81 2f       	mov	r24, r17
 56a:	df 91       	pop	r29
 56c:	cf 91       	pop	r28
 56e:	1f 91       	pop	r17
 570:	0f 91       	pop	r16
 572:	ff 90       	pop	r15
 574:	08 95       	ret
 576:	ec 01       	movw	r28, r24
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:200
			*(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);

			/* Prepare to generate ACK (or NACK in case of End Of Transmission) */
			if (msgSize == 1) // If transmission of last byte was performed.
			{
				USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
 578:	ff 24       	eor	r15, r15
 57a:	fa 94       	dec	r15
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:174
#endif

	/*Write address and Read/Write data */
	do {
		/* If masterWrite cycle (or inital address tranmission)*/
		if (USI_TWI_state.addressMode || USI_TWI_state.masterWriteDataMode) {
 57c:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <USI_TWI_state>
 580:	83 70       	andi	r24, 0x03	; 3
 582:	19 f1       	breq	.+70     	; 0x5ca <USI_TWI_Start_Transceiver_With_Data_Stop+0xac>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:176
			/* Write a byte */
			PORT_USI_CL &= ~(1 << PIN_USI_SCL);         // Pull SCL LOW.
 584:	dc 98       	cbi	0x1b, 4	; 27
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:177
			USIDR = *(msg++);                        // Setup data.
 586:	88 81       	ld	r24, Y
 588:	8f b9       	out	0x0f, r24	; 15
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:178
			USI_TWI_Master_Transfer(tempUSISR_8bit); // Send 8 bits on bus.
 58a:	80 ef       	ldi	r24, 0xF0	; 240
 58c:	b1 df       	rcall	.-158    	; 0x4f0 <USI_TWI_Master_Transfer>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:181

			/* Clock and verify (N)ACK from slave */
			DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
 58e:	d6 98       	cbi	0x1a, 6	; 26
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:182
			if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
 590:	8e ef       	ldi	r24, 0xFE	; 254
 592:	ae df       	rcall	.-164    	; 0x4f0 <USI_TWI_Master_Transfer>
 594:	80 ff       	sbrs	r24, 0
 596:	0c c0       	rjmp	.+24     	; 0x5b0 <USI_TWI_Start_Transceiver_With_Data_Stop+0x92>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:183
				if (USI_TWI_state.addressMode)
 598:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <USI_TWI_state>
 59c:	18 2f       	mov	r17, r24
 59e:	11 70       	andi	r17, 0x01	; 1
 5a0:	80 ff       	sbrs	r24, 0
 5a2:	02 c0       	rjmp	.+4      	; 0x5a8 <USI_TWI_Start_Transceiver_With_Data_Stop+0x8a>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:184
					USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 5a4:	86 e0       	ldi	r24, 0x06	; 6
 5a6:	dd cf       	rjmp	.-70     	; 0x562 <USI_TWI_Start_Transceiver_With_Data_Stop+0x44>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:186
				else
					USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
 5a8:	85 e0       	ldi	r24, 0x05	; 5
USI_TWI_Master_Stop():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:262
	PORT_USI |= (1 << PIN_USI_SDA); // Release SDA.
	DELAY_T2TWI;

#ifdef SIGNAL_VERIFY
	if (!(USISR & (1 << USIPF))) {
		USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;
 5aa:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <USI_TWI_state>
 5ae:	dc cf       	rjmp	.-72     	; 0x568 <USI_TWI_Start_Transceiver_With_Data_Stop+0x4a>
USI_TWI_Start_Transceiver_With_Data_Stop():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:189
					USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
				else
					USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
				return (FALSE);
			}
			USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
 5b0:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <USI_TWI_state>
 5b4:	8e 7f       	andi	r24, 0xFE	; 254
 5b6:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <USI_TWI_state>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:206
			} else {
				USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
			}
			USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
		}
	} while (--msgSize); // Until all data sent/received.
 5ba:	01 50       	subi	r16, 0x01	; 1
 5bc:	21 96       	adiw	r28, 0x01	; 1
 5be:	01 11       	cpse	r16, r1
 5c0:	dd cf       	rjmp	.-70     	; 0x57c <USI_TWI_Start_Transceiver_With_Data_Stop+0x5e>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:208

	if (stop) {
 5c2:	11 11       	cpse	r17, r1
 5c4:	0e c0       	rjmp	.+28     	; 0x5e2 <USI_TWI_Start_Transceiver_With_Data_Stop+0xc4>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:213
		USI_TWI_Master_Stop(); // Send a STOP condition on the TWI bus.
	}

	/* Transmission successfully completed*/
	return (TRUE);
 5c6:	11 e0       	ldi	r17, 0x01	; 1
 5c8:	cf cf       	rjmp	.-98     	; 0x568 <USI_TWI_Start_Transceiver_With_Data_Stop+0x4a>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:194
			USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
		}
		/* Else masterRead cycle*/
		else {
			/* Read a data byte */
			DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
 5ca:	d6 98       	cbi	0x1a, 6	; 26
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:195
			*(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);
 5cc:	80 ef       	ldi	r24, 0xF0	; 240
 5ce:	90 df       	rcall	.-224    	; 0x4f0 <USI_TWI_Master_Transfer>
 5d0:	88 83       	st	Y, r24
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:198

			/* Prepare to generate ACK (or NACK in case of End Of Transmission) */
			if (msgSize == 1) // If transmission of last byte was performed.
 5d2:	01 30       	cpi	r16, 0x01	; 1
 5d4:	21 f4       	brne	.+8      	; 0x5de <USI_TWI_Start_Transceiver_With_Data_Stop+0xc0>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:200
			{
				USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
 5d6:	ff b8       	out	0x0f, r15	; 15
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:204
			} else {
				USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
			}
			USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
 5d8:	8e ef       	ldi	r24, 0xFE	; 254
 5da:	8a df       	rcall	.-236    	; 0x4f0 <USI_TWI_Master_Transfer>
 5dc:	ee cf       	rjmp	.-36     	; 0x5ba <USI_TWI_Start_Transceiver_With_Data_Stop+0x9c>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:202
			/* Prepare to generate ACK (or NACK in case of End Of Transmission) */
			if (msgSize == 1) // If transmission of last byte was performed.
			{
				USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
			} else {
				USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
 5de:	1f b8       	out	0x0f, r1	; 15
 5e0:	fb cf       	rjmp	.-10     	; 0x5d8 <USI_TWI_Start_Transceiver_With_Data_Stop+0xba>
USI_TWI_Master_Stop():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:252
 Function for generating a TWI Stop Condition. Used to release
 the TWI bus.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Stop(void)
{
	PORT_USI &= ~(1 << PIN_USI_SDA); // Pull SDA low.
 5e2:	de 98       	cbi	0x1b, 6	; 27
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:253
	PORT_USI_CL |= (1 << PIN_USI_SCL);  // Release SCL.
 5e4:	dc 9a       	sbi	0x1b, 4	; 27
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:254
	while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 5e6:	cc 9b       	sbis	0x19, 4	; 25
 5e8:	fe cf       	rjmp	.-4      	; 0x5e6 <USI_TWI_Start_Transceiver_With_Data_Stop+0xc8>
_delay_us():
/home/lukilukeskywalker/.arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino5/avr/include/util/delay.h:276
 5ea:	86 e0       	ldi	r24, 0x06	; 6
 5ec:	8a 95       	dec	r24
 5ee:	f1 f7       	brne	.-4      	; 0x5ec <USI_TWI_Start_Transceiver_With_Data_Stop+0xce>
 5f0:	00 c0       	rjmp	.+0      	; 0x5f2 <USI_TWI_Start_Transceiver_With_Data_Stop+0xd4>
USI_TWI_Master_Stop():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:257
		; // Wait for SCL to go high.
	DELAY_T4TWI;
	PORT_USI |= (1 << PIN_USI_SDA); // Release SDA.
 5f2:	de 9a       	sbi	0x1b, 6	; 27
_delay_us():
/home/lukilukeskywalker/.arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino5/avr/include/util/delay.h:276
 5f4:	ee e0       	ldi	r30, 0x0E	; 14
 5f6:	ea 95       	dec	r30
 5f8:	f1 f7       	brne	.-4      	; 0x5f6 <USI_TWI_Start_Transceiver_With_Data_Stop+0xd8>
USI_TWI_Master_Stop():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:261
	DELAY_T2TWI;

#ifdef SIGNAL_VERIFY
	if (!(USISR & (1 << USIPF))) {
 5fa:	75 99       	sbic	0x0e, 5	; 14
 5fc:	e4 cf       	rjmp	.-56     	; 0x5c6 <USI_TWI_Start_Transceiver_With_Data_Stop+0xa8>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:262
		USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;
 5fe:	88 e0       	ldi	r24, 0x08	; 8
 600:	d4 cf       	rjmp	.-88     	; 0x5aa <USI_TWI_Start_Transceiver_With_Data_Stop+0x8c>

00000602 <USIWire::endTransmission() [clone .constprop.11]>:
_ZN7USIWire15endTransmissionEv.constprop.11():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:162

uint8_t USIWire::endTransmission(uint8_t sendStop) {
  // transmit buffer (blocking)
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer,
                                                         BufferLength,
                                                         sendStop);
 602:	41 e0       	ldi	r20, 0x01	; 1
 604:	60 91 b8 00 	lds	r22, 0x00B8	; 0x8000b8 <USIWire::BufferLength>
 608:	80 e6       	ldi	r24, 0x60	; 96
 60a:	90 e0       	ldi	r25, 0x00	; 0
 60c:	88 df       	rcall	.-240    	; 0x51e <USI_TWI_Start_Transceiver_With_Data_Stop>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:164
  // reset tx buffer iterator vars
  BufferIndex = 0;
 60e:	10 92 b7 00 	sts	0x00B7, r1	; 0x8000b7 <USIWire::BufferIndex>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:165
  BufferLength = 0;
 612:	10 92 b8 00 	sts	0x00B8, r1	; 0x8000b8 <USIWire::BufferLength>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:167
  // indicate that we are done transmitting
  transmitting = 0;
 616:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <USIWire::transmitting>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:169
  // check for error
  if (ret == FALSE) {
 61a:	81 11       	cpse	r24, r1
 61c:	10 c0       	rjmp	.+32     	; 0x63e <USIWire::endTransmission() [clone .constprop.11]+0x3c>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:170
    switch (USI_TWI_Get_State_Info()) {
 61e:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <USI_TWI_state>
 622:	85 30       	cpi	r24, 0x05	; 5
 624:	41 f0       	breq	.+16     	; 0x636 <USIWire::endTransmission() [clone .constprop.11]+0x34>
 626:	86 30       	cpi	r24, 0x06	; 6
 628:	21 f0       	breq	.+8      	; 0x632 <USIWire::endTransmission() [clone .constprop.11]+0x30>
 62a:	81 30       	cpi	r24, 0x01	; 1
 62c:	31 f4       	brne	.+12     	; 0x63a <USIWire::endTransmission() [clone .constprop.11]+0x38>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:172
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
 62e:	81 e0       	ldi	r24, 0x01	; 1
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:185
  return 0; //success
}

uint8_t USIWire::endTransmission(void) {
  return endTransmission(true);
}
 630:	08 95       	ret
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:174
  if (ret == FALSE) {
    switch (USI_TWI_Get_State_Info()) {
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
    case USI_TWI_NO_ACK_ON_ADDRESS:
      return 2; //received NACK on transmit of address
 632:	82 e0       	ldi	r24, 0x02	; 2
 634:	08 95       	ret
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:176
    case USI_TWI_NO_ACK_ON_DATA:
      return 3; //received NACK on transmit of data
 636:	83 e0       	ldi	r24, 0x03	; 3
 638:	08 95       	ret
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:178
    }
    return 4; //other error
 63a:	84 e0       	ldi	r24, 0x04	; 4
 63c:	08 95       	ret
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:180
  }
  return 0; //success
 63e:	80 e0       	ldi	r24, 0x00	; 0
 640:	08 95       	ret

00000642 <USIWire::requestFrom(unsigned char, unsigned char, unsigned long, unsigned char, unsigned char) [clone .constprop.7]>:
_ZN7USIWire11requestFromEhhmhh.constprop.7():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:80
void USIWire::setClock(uint32_t clock) {
  // XXX: to be implemented.
  (void)clock; //disable warning
}

uint8_t USIWire::requestFrom(uint8_t address, uint8_t quantity,
 642:	cf 93       	push	r28
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:104
    }
    endTransmission(false);
  }

  // reserve one byte for slave address
  quantity++;
 644:	c1 e0       	ldi	r28, 0x01	; 1
 646:	c6 0f       	add	r28, r22
 648:	c1 32       	cpi	r28, 0x21	; 33
 64a:	08 f0       	brcs	.+2      	; 0x64e <USIWire::requestFrom(unsigned char, unsigned char, unsigned long, unsigned char, unsigned char) [clone .constprop.7]+0xc>
 64c:	c0 e2       	ldi	r28, 0x20	; 32
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:110
  // clamp to buffer length
  if (quantity > TWI_BUFFER_SIZE) {
    quantity = TWI_BUFFER_SIZE;
  }
  // set address of targeted slave and read mode
  Buffer[0] = (address << TWI_ADR_BITS) | (1 << TWI_READ_BIT);
 64e:	88 0f       	add	r24, r24
 650:	81 60       	ori	r24, 0x01	; 1
 652:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:113
  // perform blocking read into buffer
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer, quantity,
                                                         sendStop);
 656:	41 e0       	ldi	r20, 0x01	; 1
 658:	6c 2f       	mov	r22, r28
 65a:	80 e6       	ldi	r24, 0x60	; 96
 65c:	90 e0       	ldi	r25, 0x00	; 0
 65e:	5f df       	rcall	.-322    	; 0x51e <USI_TWI_Start_Transceiver_With_Data_Stop>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:115
  // set rx buffer iterator vars
  BufferIndex = 1; // ignore slave address
 660:	91 e0       	ldi	r25, 0x01	; 1
 662:	90 93 b7 00 	sts	0x00B7, r25	; 0x8000b7 <USIWire::BufferIndex>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:117
  // check for error
  if (ret == FALSE) {
 666:	81 11       	cpse	r24, r1
 668:	04 c0       	rjmp	.+8      	; 0x672 <USIWire::requestFrom(unsigned char, unsigned char, unsigned long, unsigned char, unsigned char) [clone .constprop.7]+0x30>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:118
    BufferLength = BufferIndex;
 66a:	90 93 b8 00 	sts	0x00B8, r25	; 0x8000b8 <USIWire::BufferLength>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:124
    return 0;
  }
  BufferLength = quantity;

  return quantity - 1; // ignore slave address
}
 66e:	cf 91       	pop	r28
 670:	08 95       	ret
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:121
  // check for error
  if (ret == FALSE) {
    BufferLength = BufferIndex;
    return 0;
  }
  BufferLength = quantity;
 672:	c0 93 b8 00 	sts	0x00B8, r28	; 0x8000b8 <USIWire::BufferLength>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:123

  return quantity - 1; // ignore slave address
 676:	8f ef       	ldi	r24, 0xFF	; 255
 678:	8c 0f       	add	r24, r28
 67a:	f9 cf       	rjmp	.-14     	; 0x66e <USIWire::requestFrom(unsigned char, unsigned char, unsigned long, unsigned char, unsigned char) [clone .constprop.7]+0x2c>

0000067c <DS3231_get_time(time_struct*) [clone .constprop.4]>:
_Z15DS3231_get_timeP11time_struct.constprop.4():
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:55
  //return 0.25*temp_lsb + nint;
  return temp_lsb + (nint<<8);
  //temp_msb=25;
  //return temp_msb;
}
void DS3231_get_time(struct time_struct *t){
 67c:	cf 92       	push	r12
 67e:	df 92       	push	r13
 680:	ef 92       	push	r14
 682:	ff 92       	push	r15
 684:	cf 93       	push	r28
 686:	df 93       	push	r29
beginTransmission():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:155
  BufferIndex = 1; // reserved by slave address
  BufferLength = BufferIndex;
}

void USIWire::beginTransmission(int address) {
  beginTransmission((uint8_t)address);
 688:	88 e6       	ldi	r24, 0x68	; 104
 68a:	63 dd       	rcall	.-1338   	; 0x152 <USIWire::beginTransmission(unsigned char) [clone .constprop.10]>
write():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.h:72
    uint8_t isActive(void);

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
 68c:	80 e0       	ldi	r24, 0x00	; 0
 68e:	2e dd       	rcall	.-1444   	; 0xec <USIWire::write(unsigned char) [clone .constprop.15]>
_Z15DS3231_get_timeP11time_struct.constprop.4():
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:59
  //resetI2C();
  Wire.beginTransmission(DS3231_I2C_ADDR);
  Wire.write(DS3231_TIME_ADDR);
  Wire.endTransmission();
 690:	b8 df       	rcall	.-144    	; 0x602 <USIWire::endTransmission() [clone .constprop.11]>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:61
  uint8_t gotData = false;
  uint32_t start= millis();
 692:	ba dd       	rcall	.-1164   	; 0x208 <millis>
 694:	6b 01       	movw	r12, r22
 696:	7c 01       	movw	r14, r24
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:62
  while(millis()-start < DS3231_TRANSACTION_TIMEOUT){
 698:	b7 dd       	rcall	.-1170   	; 0x208 <millis>
 69a:	6c 19       	sub	r22, r12
 69c:	7d 09       	sbc	r23, r13
 69e:	8e 09       	sbc	r24, r14
 6a0:	9f 09       	sbc	r25, r15
 6a2:	64 36       	cpi	r22, 0x64	; 100
 6a4:	71 05       	cpc	r23, r1
 6a6:	81 05       	cpc	r24, r1
 6a8:	91 05       	cpc	r25, r1
 6aa:	b8 f4       	brcc	.+46     	; 0x6da <DS3231_get_time(time_struct*) [clone .constprop.4]+0x5e>
requestFrom():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:129
}

uint8_t USIWire::requestFrom(uint8_t address, uint8_t quantity,
                             uint8_t sendStop) {
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint32_t)0,
                     (uint8_t)0, (uint8_t)sendStop);
 6ac:	63 e0       	ldi	r22, 0x03	; 3
 6ae:	88 e6       	ldi	r24, 0x68	; 104
 6b0:	c8 df       	rcall	.-112    	; 0x642 <USIWire::requestFrom(unsigned char, unsigned char, unsigned long, unsigned char, unsigned char) [clone .constprop.7]>
_Z15DS3231_get_timeP11time_struct.constprop.4():
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:63
    if(Wire.requestFrom(DS3231_I2C_ADDR, 3)==3){
 6b2:	83 30       	cpi	r24, 0x03	; 3
 6b4:	89 f7       	brne	.-30     	; 0x698 <DS3231_get_time(time_struct*) [clone .constprop.4]+0x1c>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:84
  //uint8_t n;
  uint8_t Time[3];
  for(uint8_t i=0; i<=2; i++){
    //n = Wire.read();
    //Time[i]=bcdtodec(n);
    Time[i]=Wire.read();
 6b6:	ec dc       	rcall	.-1576   	; 0x90 <USIWire::read() [clone .constprop.16]>
 6b8:	d8 2f       	mov	r29, r24
 6ba:	ea dc       	rcall	.-1580   	; 0x90 <USIWire::read() [clone .constprop.16]>
 6bc:	c8 2f       	mov	r28, r24
 6be:	e8 dc       	rcall	.-1584   	; 0x90 <USIWire::read() [clone .constprop.16]>
 6c0:	d0 93 b0 00 	sts	0x00B0, r29	; 0x8000b0 <time+0x2>
 6c4:	c0 93 af 00 	sts	0x00AF, r28	; 0x8000af <time+0x1>
 6c8:	80 93 ae 00 	sts	0x00AE, r24	; 0x8000ae <time>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:90
  }
  t->second = Time[0];  //If we just save the data as bcd, then we dont need to do a later conversion
  t->minute = Time[1];
  t->hour   = Time[2];
  Wire.endTransmission();
}
 6cc:	df 91       	pop	r29
 6ce:	cf 91       	pop	r28
 6d0:	ff 90       	pop	r15
 6d2:	ef 90       	pop	r14
 6d4:	df 90       	pop	r13
 6d6:	cf 90       	pop	r12
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:89
    Time[i]=Wire.read();
  }
  t->second = Time[0];  //If we just save the data as bcd, then we dont need to do a later conversion
  t->minute = Time[1];
  t->hour   = Time[2];
  Wire.endTransmission();
 6d8:	94 cf       	rjmp	.-216    	; 0x602 <USIWire::endTransmission() [clone .constprop.11]>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:71
    }
  }
  
  if (!gotData){
    //return;
      DDRA |= (0X01 << 2);
 6da:	d2 9a       	sbi	0x1a, 2	; 26
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:72
      PORTA |= (1 << 2);
 6dc:	da 9a       	sbi	0x1b, 2	; 27
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:73
      DDRA |= (0X01 << 1);
 6de:	d1 9a       	sbi	0x1a, 1	; 26
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:74
      PORTA |= (0 << 1);
 6e0:	8b b3       	in	r24, 0x1b	; 27
 6e2:	8b bb       	out	0x1b, r24	; 27
 6e4:	ff cf       	rjmp	.-2      	; 0x6e4 <DS3231_get_time(time_struct*) [clone .constprop.4]+0x68>

000006e6 <__vector_11>:
__vector_11():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:133
#else

#error Millis() timer not defined!

#endif
{
 6e6:	1f 92       	push	r1
 6e8:	0f 92       	push	r0
 6ea:	0f b6       	in	r0, 0x3f	; 63
 6ec:	0f 92       	push	r0
 6ee:	11 24       	eor	r1, r1
 6f0:	2f 93       	push	r18
 6f2:	3f 93       	push	r19
 6f4:	8f 93       	push	r24
 6f6:	9f 93       	push	r25
 6f8:	af 93       	push	r26
 6fa:	bf 93       	push	r27
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:136
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)
  unsigned long m = millis_timer_millis;
 6fc:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <millis_timer_millis>
 700:	90 91 a7 00 	lds	r25, 0x00A7	; 0x8000a7 <millis_timer_millis+0x1>
 704:	a0 91 a8 00 	lds	r26, 0x00A8	; 0x8000a8 <millis_timer_millis+0x2>
 708:	b0 91 a9 00 	lds	r27, 0x00A9	; 0x8000a9 <millis_timer_millis+0x3>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:137
  unsigned char f = millis_timer_fract;
 70c:	30 91 a5 00 	lds	r19, 0x00A5	; 0x8000a5 <millis_timer_fract>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:149
    f -= FRACT_MAX;
    m += 1;
  }
...rmv */

  f += FRACT_INC;
 710:	26 e0       	ldi	r18, 0x06	; 6
 712:	23 0f       	add	r18, r19
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:151

  if (f >= FRACT_MAX)
 714:	2d 37       	cpi	r18, 0x7D	; 125
 716:	68 f1       	brcs	.+90     	; 0x772 <__vector_11+0x8c>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:153
  {
    f -= FRACT_MAX;
 718:	29 e8       	ldi	r18, 0x89	; 137
 71a:	23 0f       	add	r18, r19
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:155
  m += 1;
    m += MILLIS_INC;
 71c:	03 96       	adiw	r24, 0x03	; 3
 71e:	a1 1d       	adc	r26, r1
 720:	b1 1d       	adc	r27, r1
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:162
  else
  {
    m += MILLIS_INC;
  }

  millis_timer_fract = f;
 722:	20 93 a5 00 	sts	0x00A5, r18	; 0x8000a5 <millis_timer_fract>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:163
  millis_timer_millis = m;
 726:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <millis_timer_millis>
 72a:	90 93 a7 00 	sts	0x00A7, r25	; 0x8000a7 <millis_timer_millis+0x1>
 72e:	a0 93 a8 00 	sts	0x00A8, r26	; 0x8000a8 <millis_timer_millis+0x2>
 732:	b0 93 a9 00 	sts	0x00A9, r27	; 0x8000a9 <millis_timer_millis+0x3>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:164
  millis_timer_overflow_count++;
 736:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <millis_timer_overflow_count>
 73a:	90 91 ab 00 	lds	r25, 0x00AB	; 0x8000ab <millis_timer_overflow_count+0x1>
 73e:	a0 91 ac 00 	lds	r26, 0x00AC	; 0x8000ac <millis_timer_overflow_count+0x2>
 742:	b0 91 ad 00 	lds	r27, 0x00AD	; 0x8000ad <millis_timer_overflow_count+0x3>
 746:	01 96       	adiw	r24, 0x01	; 1
 748:	a1 1d       	adc	r26, r1
 74a:	b1 1d       	adc	r27, r1
 74c:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <millis_timer_overflow_count>
 750:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <millis_timer_overflow_count+0x1>
 754:	a0 93 ac 00 	sts	0x00AC, r26	; 0x8000ac <millis_timer_overflow_count+0x2>
 758:	b0 93 ad 00 	sts	0x00AD, r27	; 0x8000ad <millis_timer_overflow_count+0x3>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:171

//MICROSECONDS_PER_MILLIS_OVERFLOW=2048
//MILLIS_INC=2
//FRACT_INC=6
//FRACT_MAX=125
}
 75c:	bf 91       	pop	r27
 75e:	af 91       	pop	r26
 760:	9f 91       	pop	r25
 762:	8f 91       	pop	r24
 764:	3f 91       	pop	r19
 766:	2f 91       	pop	r18
 768:	0f 90       	pop	r0
 76a:	0f be       	out	0x3f, r0	; 63
 76c:	0f 90       	pop	r0
 76e:	1f 90       	pop	r1
 770:	18 95       	reti
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:159
  m += 1;
    m += MILLIS_INC;
  }
  else
  {
    m += MILLIS_INC;
 772:	02 96       	adiw	r24, 0x02	; 2
 774:	a1 1d       	adc	r26, r1
 776:	b1 1d       	adc	r27, r1
 778:	d4 cf       	rjmp	.-88     	; 0x722 <__vector_11+0x3c>

0000077a <__vector_16>:
__vector_16():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:209
ISR(USI_OVERFLOW_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_OVERFLOW_VECTOR
__interrupt void USI_Counter_Overflow_ISR(void)
#endif
{
 77a:	1f 92       	push	r1
 77c:	0f 92       	push	r0
 77e:	0f b6       	in	r0, 0x3f	; 63
 780:	0f 92       	push	r0
 782:	11 24       	eor	r1, r1
 784:	2f 93       	push	r18
 786:	8f 93       	push	r24
 788:	9f 93       	push	r25
 78a:	ef 93       	push	r30
 78c:	ff 93       	push	r31
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:214
	unsigned char tmpRxHead;
	unsigned char tmpTxTail; // Temporary variables to store volatiles
	unsigned char tmpUSIDR;

	switch (USI_TWI_Overflow_State) {
 78e:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <USI_TWI_Overflow_State>
 792:	82 30       	cpi	r24, 0x02	; 2
 794:	09 f4       	brne	.+2      	; 0x798 <__vector_16+0x1e>
 796:	5e c0       	rjmp	.+188    	; 0x854 <__vector_16+0xda>
 798:	78 f4       	brcc	.+30     	; 0x7b8 <__vector_16+0x3e>
 79a:	88 23       	and	r24, r24
 79c:	49 f1       	breq	.+82     	; 0x7f0 <__vector_16+0x76>
 79e:	81 30       	cpi	r24, 0x01	; 1
 7a0:	09 f4       	brne	.+2      	; 0x7a4 <__vector_16+0x2a>
 7a2:	3e c0       	rjmp	.+124    	; 0x820 <__vector_16+0xa6>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:307
		{
			SET_USI_TO_SEND_NACK();
		}
		break;
	}
}
 7a4:	ff 91       	pop	r31
 7a6:	ef 91       	pop	r30
 7a8:	9f 91       	pop	r25
 7aa:	8f 91       	pop	r24
 7ac:	2f 91       	pop	r18
 7ae:	0f 90       	pop	r0
 7b0:	0f be       	out	0x3f, r0	; 63
 7b2:	0f 90       	pop	r0
 7b4:	1f 90       	pop	r1
 7b6:	18 95       	reti
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:214
{
	unsigned char tmpRxHead;
	unsigned char tmpTxTail; // Temporary variables to store volatiles
	unsigned char tmpUSIDR;

	switch (USI_TWI_Overflow_State) {
 7b8:	84 30       	cpi	r24, 0x04	; 4
 7ba:	09 f4       	brne	.+2      	; 0x7be <__vector_16+0x44>
 7bc:	51 c0       	rjmp	.+162    	; 0x860 <__vector_16+0xe6>
 7be:	48 f1       	brcs	.+82     	; 0x812 <__vector_16+0x98>
 7c0:	85 30       	cpi	r24, 0x05	; 5
 7c2:	81 f7       	brne	.-32     	; 0x7a4 <__vector_16+0x2a>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:294
		break;

	// Copy data from USIDR and send ACK. Next USI_SLAVE_REQUEST_DATA
	case USI_SLAVE_GET_DATA_AND_SEND_ACK:
		// Put data into Buffer
		USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 7c4:	84 e0       	ldi	r24, 0x04	; 4
 7c6:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <USI_TWI_Overflow_State>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:295
		tmpUSIDR              = USIDR; // Not necessary, but prevents warnings
 7ca:	9f b1       	in	r25, 0x0f	; 15
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:296
		tmpRxHead = (TWI_RxHead + 1) & TWI_RX_BUFFER_MASK;
 7cc:	80 91 b5 00 	lds	r24, 0x00B5	; 0x8000b5 <TWI_RxHead>
 7d0:	8f 5f       	subi	r24, 0xFF	; 255
 7d2:	8f 70       	andi	r24, 0x0F	; 15
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:297
		if (TWI_RxTail != tmpRxHead) {
 7d4:	20 91 b6 00 	lds	r18, 0x00B6	; 0x8000b6 <TWI_RxTail>
 7d8:	28 17       	cp	r18, r24
 7da:	09 f4       	brne	.+2      	; 0x7de <__vector_16+0x64>
 7dc:	46 c0       	rjmp	.+140    	; 0x86a <__vector_16+0xf0>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:298
			TWI_RxHead            = tmpRxHead;
 7de:	80 93 b5 00 	sts	0x00B5, r24	; 0x8000b5 <TWI_RxHead>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:299
			TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
 7e2:	e0 91 b5 00 	lds	r30, 0x00B5	; 0x8000b5 <TWI_RxHead>
 7e6:	f0 e0       	ldi	r31, 0x00	; 0
 7e8:	e0 5a       	subi	r30, 0xA0	; 160
 7ea:	ff 4f       	sbci	r31, 0xFF	; 255
 7ec:	90 83       	st	Z, r25
 7ee:	0b c0       	rjmp	.+22     	; 0x806 <__vector_16+0x8c>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:218

	switch (USI_TWI_Overflow_State) {
	// ---------- Address mode ----------
	// Check address and send ACK (and next USI_SLAVE_SEND_DATA) if OK, else reset USI.
	case USI_SLAVE_CHECK_ADDRESS:
		if ((USIDR == 0) || ((USIDR >> 1) == TWI_slaveAddress)) {
 7f0:	8f b1       	in	r24, 0x0f	; 15
 7f2:	88 23       	and	r24, r24
 7f4:	19 f0       	breq	.+6      	; 0x7fc <__vector_16+0x82>
 7f6:	8f b1       	in	r24, 0x0f	; 15
 7f8:	86 95       	lsr	r24
 7fa:	71 f4       	brne	.+28     	; 0x818 <__vector_16+0x9e>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:219
			if (USIDR & 0x01) {
 7fc:	78 9b       	sbis	0x0f, 0	; 15
 7fe:	07 c0       	rjmp	.+14     	; 0x80e <__vector_16+0x94>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:226
					// reset tx buffer and call callback
					tmpTxTail = TWI_TxHead;
					TWI_TxTail = tmpTxTail;
					USI_TWI_On_Slave_Transmit();
				}
				USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
 800:	81 e0       	ldi	r24, 0x01	; 1
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:228
			} else {
				USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 802:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <USI_TWI_Overflow_State>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:230
			}
			SET_USI_TO_SEND_ACK();
 806:	1f b8       	out	0x0f, r1	; 15
 808:	d6 9a       	sbi	0x1a, 6	; 26
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:303
			TWI_RxHead            = tmpRxHead;
			TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
			SET_USI_TO_SEND_ACK();
		} else // If the buffer is full then:
		{
			SET_USI_TO_SEND_NACK();
 80a:	8e e7       	ldi	r24, 0x7E	; 126
 80c:	21 c0       	rjmp	.+66     	; 0x850 <__vector_16+0xd6>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:228
					TWI_TxTail = tmpTxTail;
					USI_TWI_On_Slave_Transmit();
				}
				USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
			} else {
				USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 80e:	84 e0       	ldi	r24, 0x04	; 4
 810:	f8 cf       	rjmp	.-16     	; 0x802 <__vector_16+0x88>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:239
		break;

	// ----- Master write data mode ------
	// Check reply and goto USI_SLAVE_SEND_DATA if OK, else reset USI.
	case USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA:
		if (USIDR) // If NACK, the master does not want more data.
 812:	8f b1       	in	r24, 0x0f	; 15
 814:	88 23       	and	r24, r24
 816:	21 f0       	breq	.+8      	; 0x820 <__vector_16+0xa6>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:256
		if (TWI_TxHead != tmpTxTail) {
			TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
			USIDR      = TWI_TxBuf[TWI_TxTail];
		} else // If the buffer is empty then:
		{
			SET_USI_TO_TWI_START_CONDITION_MODE();
 818:	d6 98       	cbi	0x1a, 6	; 26
 81a:	88 ea       	ldi	r24, 0xA8	; 168
 81c:	8d b9       	out	0x0d, r24	; 13
 81e:	17 c0       	rjmp	.+46     	; 0x84e <__vector_16+0xd4>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:250

	// Copy data from buffer to USIDR and set USI to shift byte. Next USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA
	case USI_SLAVE_SEND_DATA:

		// Get data from Buffer
		tmpTxTail = TWI_TxTail; // Not necessary, but prevents warnings
 820:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <TWI_TxTail>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:251
		if (TWI_TxHead != tmpTxTail) {
 824:	90 91 b3 00 	lds	r25, 0x00B3	; 0x8000b3 <TWI_TxHead>
 828:	98 17       	cp	r25, r24
 82a:	b1 f3       	breq	.-20     	; 0x818 <__vector_16+0x9e>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:252
			TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
 82c:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <TWI_TxTail>
 830:	8f 5f       	subi	r24, 0xFF	; 255
 832:	8f 70       	andi	r24, 0x0F	; 15
 834:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <TWI_TxTail>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:253
			USIDR      = TWI_TxBuf[TWI_TxTail];
 838:	e0 91 b2 00 	lds	r30, 0x00B2	; 0x8000b2 <TWI_TxTail>
 83c:	f0 e0       	ldi	r31, 0x00	; 0
 83e:	e0 59       	subi	r30, 0x90	; 144
 840:	ff 4f       	sbci	r31, 0xFF	; 255
 842:	80 81       	ld	r24, Z
 844:	8f b9       	out	0x0f, r24	; 15
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:259
		} else // If the buffer is empty then:
		{
			SET_USI_TO_TWI_START_CONDITION_MODE();
			return;
		}
		USI_TWI_Overflow_State = USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA;
 846:	82 e0       	ldi	r24, 0x02	; 2
 848:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <USI_TWI_Overflow_State>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:260
		SET_USI_TO_SEND_DATA();
 84c:	d6 9a       	sbi	0x1a, 6	; 26
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:273

	// ----- Master read data mode ------
	// Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
	case USI_SLAVE_REQUEST_DATA:
		USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
		SET_USI_TO_READ_DATA();
 84e:	80 e7       	ldi	r24, 0x70	; 112
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:303
			TWI_RxHead            = tmpRxHead;
			TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
			SET_USI_TO_SEND_ACK();
		} else // If the buffer is full then:
		{
			SET_USI_TO_SEND_NACK();
 850:	8e b9       	out	0x0e, r24	; 14
 852:	a8 cf       	rjmp	.-176    	; 0x7a4 <__vector_16+0x2a>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:265
		SET_USI_TO_SEND_DATA();
		break;

	// Set USI to sample reply from master. Next USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA
	case USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA:
		USI_TWI_Overflow_State = USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA;
 854:	83 e0       	ldi	r24, 0x03	; 3
 856:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <USI_TWI_Overflow_State>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:266
		SET_USI_TO_READ_ACK();
 85a:	d6 98       	cbi	0x1a, 6	; 26
 85c:	1f b8       	out	0x0f, r1	; 15
 85e:	d5 cf       	rjmp	.-86     	; 0x80a <__vector_16+0x90>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:272
		break;

	// ----- Master read data mode ------
	// Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
	case USI_SLAVE_REQUEST_DATA:
		USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
 860:	85 e0       	ldi	r24, 0x05	; 5
 862:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <USI_TWI_Overflow_State>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:273
		SET_USI_TO_READ_DATA();
 866:	d6 98       	cbi	0x1a, 6	; 26
 868:	f2 cf       	rjmp	.-28     	; 0x84e <__vector_16+0xd4>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:303
			TWI_RxHead            = tmpRxHead;
			TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
			SET_USI_TO_SEND_ACK();
		} else // If the buffer is full then:
		{
			SET_USI_TO_SEND_NACK();
 86a:	d6 98       	cbi	0x1a, 6	; 26
 86c:	ce cf       	rjmp	.-100    	; 0x80a <__vector_16+0x90>

0000086e <__vector_15>:
__vector_15():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:162
ISR(USI_START_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_START_VECTOR
__interrupt void USI_Start_Condition_ISR(void)
#endif
{
 86e:	1f 92       	push	r1
 870:	0f 92       	push	r0
 872:	0f b6       	in	r0, 0x3f	; 63
 874:	0f 92       	push	r0
 876:	11 24       	eor	r1, r1
 878:	8f 93       	push	r24
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:175
			// reset rx buffer
			TWI_RxTail = tmpRxHead;
		}
	}

	USI_TWI_Overflow_State = USI_SLAVE_CHECK_ADDRESS;
 87a:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <USI_TWI_Overflow_State>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:176
	DDR_USI &= ~(1 << PORT_USI_SDA); // Set SDA as input
 87e:	d6 98       	cbi	0x1a, 6	; 26
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:177
	while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
 880:	cc 9b       	sbis	0x19, 4	; 25
 882:	04 c0       	rjmp	.+8      	; 0x88c <__vector_15+0x1e>
 884:	ce 9b       	sbis	0x19, 6	; 25
 886:	fc cf       	rjmp	.-8      	; 0x880 <__vector_15+0x12>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:182
		; // Wait for SCL to go low to ensure the "Start Condition" has completed.
	      // If a Stop condition arises then leave the interrupt to prevent waiting forever.
	if (tmpPin) {
		// Stop Condition (waiting for next Start Condition)
		USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 888:	88 ea       	ldi	r24, 0xA8	; 168
 88a:	01 c0       	rjmp	.+2      	; 0x88e <__vector_15+0x20>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:189
		                                        // to first Start Condition (potentail failure)
		        (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
		        (0 << USITC);
	} else {
		// really Start Condition (Enable Overflow Interrupt)
		USICR = (1 << USISIE) | (1 << USIOIE)
 88c:	88 ef       	ldi	r24, 0xF8	; 248
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:182
	while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
		; // Wait for SCL to go low to ensure the "Start Condition" has completed.
	      // If a Stop condition arises then leave the interrupt to prevent waiting forever.
	if (tmpPin) {
		// Stop Condition (waiting for next Start Condition)
		USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 88e:	8d b9       	out	0x0d, r24	; 13
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:195
		        | // Enable Overflow and Start Condition Interrupt. (Keep StartCondInt to detect RESTART)
		        (1 << USIWM1) | (1 << USIWM0) |                 // Set USI in Two-wire mode.
		        (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
		        (0 << USITC);
	}
	USISR = (1 << USI_START_COND_INT) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags
 890:	80 ef       	ldi	r24, 0xF0	; 240
 892:	8e b9       	out	0x0e, r24	; 14
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Slave/USI_TWI_Slave.c:197
	        (0x0 << USICNT0); // Set USI to sample 8 bits i.e. count 16 external pin toggles.
}
 894:	8f 91       	pop	r24
 896:	0f 90       	pop	r0
 898:	0f be       	out	0x3f, r0	; 63
 89a:	0f 90       	pop	r0
 89c:	1f 90       	pop	r1
 89e:	18 95       	reti

000008a0 <main>:
main():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/main.cpp:6
#include <Arduino.h>

int main(void)
{
  #ifdef TUNED_OSCCAL_VALUE
  OSCCAL = TUNED_OSCCAL_VALUE; //set the oscillator calibration value based on the pins_arduino.h file. If this is not set, it will be optimised away
 8a0:	81 b7       	in	r24, 0x31	; 49
 8a2:	81 bf       	out	0x31, r24	; 49
init():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:699
    } else {
      OSCCAL += 5;
    }
  }
  #endif
  sei();
 8a4:	78 94       	sei
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:831
  #endif
  #endif

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0) && defined(WGM01)
  sbi(TCCR0A, WGM01);
 8a6:	80 b7       	in	r24, 0x30	; 48
 8a8:	82 60       	ori	r24, 0x02	; 2
 8aa:	80 bf       	out	0x30, r24	; 48
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:832
  sbi(TCCR0A, WGM00);
 8ac:	80 b7       	in	r24, 0x30	; 48
 8ae:	81 60       	ori	r24, 0x01	; 1
 8b0:	80 bf       	out	0x30, r24	; 48
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:855
  #endif

  // Millis timer is always processor clock divided by MillisTimer_Prescale_Value (64)
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
   #ifdef TCCR0B
    TCCR0B = (TCCR0B & ~((1<<CS02)|(1<<CS01)|(1<<CS00))) | (MillisTimer_Prescale_Index << CS00);
 8b2:	83 b7       	in	r24, 0x33	; 51
 8b4:	88 7f       	andi	r24, 0xF8	; 248
 8b6:	83 60       	ori	r24, 0x03	; 3
 8b8:	83 bf       	out	0x33, r24	; 51
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:867
  TCCR1B = (TCCR1B & ~((1<<CS13)|(1<<CS12)|(1<<CS11)|(1<<CS10))) | (MillisTimer_Prescale_Index << CS10);
  #elif (TIMER_TO_USE_FOR_MILLIS == 1)
  TCCR1B = (TCCR1B & ~((1<<CS12)|(1<<CS11)|(1<<CS10))) | (MillisTimer_Prescale_Index << CS10);
  #endif
  // this needs to be called before setup() or some functions won't work there
  sei();
 8ba:	78 94       	sei
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:874
  #ifndef DISABLEMILLIS
  // Enable the overlow interrupt (this is the basic system tic-toc for millis)
  #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  sbi(TIMSK, TOIE0);
  #elif defined(TIMSK0) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  sbi(TIMSK0, TOIE0);
 8bc:	89 b7       	in	r24, 0x39	; 57
 8be:	81 60       	ori	r24, 0x01	; 1
 8c0:	89 bf       	out	0x39, r24	; 57
initToneTimerInternal():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:526
  sbi(TCCR1C, PWM1D);
  cbi(TCCR1D, WGM11);
  sbi(TCCR1D, WGM10);
  TCCR1B |= (ToneTimer_Prescale_Index << CS10);
  #elif (TIMER_TO_USE_FOR_TONE == 1)
  TCCR1B &= ~((1<<CS12) | (1<<CS11) | (1<<CS10)); //stop the clock to configure
 8c2:	8e b5       	in	r24, 0x2e	; 46
 8c4:	88 7f       	andi	r24, 0xF8	; 248
 8c6:	8e bd       	out	0x2e, r24	; 46
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:528
  // Use the Tone Timer for phase correct PWM
  sbi(TCCR1A, WGM10);
 8c8:	8f b5       	in	r24, 0x2f	; 47
 8ca:	81 60       	ori	r24, 0x01	; 1
 8cc:	8f bd       	out	0x2f, r24	; 47
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:529
  cbi(TCCR1A, WGM11);
 8ce:	8f b5       	in	r24, 0x2f	; 47
 8d0:	8d 7f       	andi	r24, 0xFD	; 253
 8d2:	8f bd       	out	0x2f, r24	; 47
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:530
  cbi(TCCR1B, WGM12);
 8d4:	8e b5       	in	r24, 0x2e	; 46
 8d6:	87 7f       	andi	r24, 0xF7	; 247
 8d8:	8e bd       	out	0x2e, r24	; 46
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:531
  cbi(TCCR1B, WGM13);
 8da:	8e b5       	in	r24, 0x2e	; 46
 8dc:	8f 7e       	andi	r24, 0xEF	; 239
 8de:	8e bd       	out	0x2e, r24	; 46
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:532
  TCCR1B |= (ToneTimer_Prescale_Index << CS10); //set the clock
 8e0:	8e b5       	in	r24, 0x2e	; 46
 8e2:	83 60       	ori	r24, 0x03	; 3
 8e4:	8e bd       	out	0x2e, r24	; 46
init():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:893

  // Initialize the ADC
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
  #if defined(ADCSRA)
    // set a2d prescale factor
  ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 8e6:	86 b1       	in	r24, 0x06	; 6
 8e8:	88 77       	andi	r24, 0x78	; 120
 8ea:	86 68       	ori	r24, 0x86	; 134
 8ec:	86 b9       	out	0x06, r24	; 6
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring.c:895
    // enable a2d conversions
    sbi(ADCSRA, ADEN);
 8ee:	37 9a       	sbi	0x06, 7	; 6
begin():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:50
}

// Public Methods //////////////////////////////////////////////////////////////

void USIWire::begin(void) {
  BufferIndex = 0;
 8f0:	10 92 b7 00 	sts	0x00B7, r1	; 0x8000b7 <USIWire::BufferIndex>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:51
  BufferLength = 0;
 8f4:	10 92 b8 00 	sts	0x00B8, r1	; 0x8000b8 <USIWire::BufferLength>
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:53

  transmitting = 0;
 8f8:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <USIWire::transmitting>
USI_TWI_Master_Initialise():
/*---------------------------------------------------------------
 USI TWI single master initialization function
---------------------------------------------------------------*/
void USI_TWI_Master_Initialise(void)
{
	PORT_USI |= (1 << PIN_USI_SDA); // Enable pullup on SDA, to set high as released state.
 8fc:	de 9a       	sbi	0x1b, 6	; 27
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:54
	PORT_USI_CL |= (1 << PIN_USI_SCL); // Enable pullup on SCL, to set high as released state.
 8fe:	dc 9a       	sbi	0x1b, 4	; 27
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:56

	DDR_USI_CL |= (1 << PIN_USI_SCL); // Enable SCL as output.
 900:	d4 9a       	sbi	0x1a, 4	; 26
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:57
	DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
 902:	d6 9a       	sbi	0x1a, 6	; 26
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:59

	USIDR = 0xFF;                                           // Preload dataregister with "released level" data.
 904:	8f ef       	ldi	r24, 0xFF	; 255
 906:	8f b9       	out	0x0f, r24	; 15
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:60
	USICR = (0 << USISIE) | (0 << USIOIE) |                 // Disable Interrupts.
 908:	8a e2       	ldi	r24, 0x2A	; 42
 90a:	8d b9       	out	0x0d, r24	; 13
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USI_TWI_Master/USI_TWI_Master.c:64
	        (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
	        (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software stobe as counter clock source
	        (0 << USITC);
	USISR = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags,
 90c:	80 ef       	ldi	r24, 0xF0	; 240
 90e:	8e b9       	out	0x0e, r24	; 14
beginTransmission():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:155
  BufferIndex = 1; // reserved by slave address
  BufferLength = BufferIndex;
}

void USIWire::beginTransmission(int address) {
  beginTransmission((uint8_t)address);
 910:	88 e6       	ldi	r24, 0x68	; 104
 912:	1f dc       	rcall	.-1986   	; 0x152 <USIWire::beginTransmission(unsigned char) [clone .constprop.10]>
DS3231_get_addr():
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:107
  Wire.endTransmission();
}
uint8_t DS3231_get_addr(uint8_t addr){
  //resetI2C();
  Wire.beginTransmission(DS3231_I2C_ADDR);
  Wire.write(addr);
 914:	8f e0       	ldi	r24, 0x0F	; 15
 916:	ea db       	rcall	.-2092   	; 0xec <USIWire::write(unsigned char) [clone .constprop.15]>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:108
  Wire.endTransmission();
 918:	74 de       	rcall	.-792    	; 0x602 <USIWire::endTransmission() [clone .constprop.11]>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:111
  uint8_t rv;
    uint8_t gotData = false;
  uint32_t start = millis(); // start timeout
 91a:	76 dc       	rcall	.-1812   	; 0x208 <millis>
 91c:	6b 01       	movw	r12, r22
 91e:	7c 01       	movw	r14, r24
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:112
  while(millis()-start < DS3231_TRANSACTION_TIMEOUT){
 920:	73 dc       	rcall	.-1818   	; 0x208 <millis>
 922:	6c 19       	sub	r22, r12
 924:	7d 09       	sbc	r23, r13
 926:	8e 09       	sbc	r24, r14
 928:	9f 09       	sbc	r25, r15
 92a:	64 36       	cpi	r22, 0x64	; 100
 92c:	71 05       	cpc	r23, r1
 92e:	81 05       	cpc	r24, r1
 930:	91 05       	cpc	r25, r1
 932:	60 f4       	brcc	.+24     	; 0x94c <main+0xac>
requestFrom():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:129
}

uint8_t USIWire::requestFrom(uint8_t address, uint8_t quantity,
                             uint8_t sendStop) {
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint32_t)0,
                     (uint8_t)0, (uint8_t)sendStop);
 934:	61 e0       	ldi	r22, 0x01	; 1
 936:	88 e6       	ldi	r24, 0x68	; 104
 938:	84 de       	rcall	.-760    	; 0x642 <USIWire::requestFrom(unsigned char, unsigned char, unsigned long, unsigned char, unsigned char) [clone .constprop.7]>
 93a:	18 2f       	mov	r17, r24
DS3231_get_addr():
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:113
    if (Wire.requestFrom(DS3231_I2C_ADDR, 1) == 1) {
 93c:	81 30       	cpi	r24, 0x01	; 1
 93e:	39 f0       	breq	.+14     	; 0x94e <main+0xae>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:117
        gotData = true;
        break;
      }
      delay(2);
 940:	62 e0       	ldi	r22, 0x02	; 2
 942:	70 e0       	ldi	r23, 0x00	; 0
 944:	80 e0       	ldi	r24, 0x00	; 0
 946:	90 e0       	ldi	r25, 0x00	; 0
 948:	35 dc       	rcall	.-1942   	; 0x1b4 <delay>
 94a:	ea cf       	rjmp	.-44     	; 0x920 <main+0x80>
main():
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:110
  //resetI2C();
  Wire.beginTransmission(DS3231_I2C_ADDR);
  Wire.write(addr);
  Wire.endTransmission();
  uint8_t rv;
    uint8_t gotData = false;
 94c:	10 e0       	ldi	r17, 0x00	; 0
DS3231_get_addr():
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:119
        gotData = true;
        break;
      }
      delay(2);
    }
  Wire.endTransmission();
 94e:	59 de       	rcall	.-846    	; 0x602 <USIWire::endTransmission() [clone .constprop.11]>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:120
  if (!gotData)
 950:	11 11       	cpse	r17, r1
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:122
      return 0; // error timeout
    rv = Wire.read();
 952:	9e db       	rcall	.-2244   	; 0x90 <USIWire::read() [clone .constprop.16]>
beginTransmission():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:155
  BufferIndex = 1; // reserved by slave address
  BufferLength = BufferIndex;
}

void USIWire::beginTransmission(int address) {
  beginTransmission((uint8_t)address);
 954:	88 e6       	ldi	r24, 0x68	; 104
 956:	fd db       	rcall	.-2054   	; 0x152 <USIWire::beginTransmission(unsigned char) [clone .constprop.10]>
DS3231_set_addr():
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:100
  DS3231_set_addr(DS3231_STATUS_ADDR, sreg);
}
void DS3231_set_addr(uint8_t addr, uint8_t val){
  //resetI2C();
  Wire.beginTransmission(DS3231_I2C_ADDR);
  Wire.write(addr);
 958:	8f e0       	ldi	r24, 0x0F	; 15
 95a:	c8 db       	rcall	.-2160   	; 0xec <USIWire::write(unsigned char) [clone .constprop.15]>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:101
  Wire.write(val);
 95c:	80 e0       	ldi	r24, 0x00	; 0
 95e:	c6 db       	rcall	.-2164   	; 0xec <USIWire::write(unsigned char) [clone .constprop.15]>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:102
  Wire.endTransmission();
 960:	50 de       	rcall	.-864    	; 0x602 <USIWire::endTransmission() [clone .constprop.11]>
setup():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:46
void setup() {
  //wdt_disable();
  Wire.begin();
  DS3231_init();
  //Rtc.Begin();
  DS3231_get_time(&time);
 962:	8c de       	rcall	.-744    	; 0x67c <DS3231_get_time(time_struct*) [clone .constprop.4]>
loop():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:188
void loop() {
  //A ver... Los pines de los leds son el PFO, PF1, PF4, PF5, PF6. Con solo 5 pines podemos charliplexar 20 Leds. Ahora solo hay que conseguir escribir el codigo.
  //Con el registrp DDX, en este caso DDF, seleccionamos si deseamos el pin en estado salida o entrada. Si queremos que tenga una alta impedancia, lo seleccionamos a entrada, poniendolo
  //en  0, o en 1 si lo queremos como salida. 
  //En el registro PORTX, selecionamos el estado. Osea HIGH o LOW
  if(time.minute%10==0 && time.second==0){
 964:	6a e0       	ldi	r22, 0x0A	; 10
 966:	26 2e       	mov	r2, r22
pinMode():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:35
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t bit = digitalPinToBitMask(pin);
 968:	07 e4       	ldi	r16, 0x47	; 71
 96a:	10 e0       	ldi	r17, 0x00	; 0
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:36
  uint8_t port = digitalPinToPort(pin);
 96c:	7b e3       	ldi	r23, 0x3B	; 59
 96e:	a7 2e       	mov	r10, r23
 970:	70 e0       	ldi	r23, 0x00	; 0
 972:	b7 2e       	mov	r11, r23
digitalRead():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:168
}

int digitalRead(uint8_t pin)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t timer = digitalPinToTimer(pin);
 974:	e3 e5       	ldi	r30, 0x53	; 83
 976:	8e 2e       	mov	r8, r30
 978:	e0 e0       	ldi	r30, 0x00	; 0
 97a:	9e 2e       	mov	r9, r30
loop():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:188
 97c:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <time+0x1>
 980:	62 2d       	mov	r22, r2
 982:	08 d2       	rcall	.+1040   	; 0xd94 <__udivmodqi4>
 984:	91 11       	cpse	r25, r1
 986:	05 c0       	rjmp	.+10     	; 0x992 <main+0xf2>
 988:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <time+0x2>
 98c:	81 11       	cpse	r24, r1
 98e:	01 c0       	rjmp	.+2      	; 0x992 <main+0xf2>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:190
    //Wire.begin();
    DS3231_get_time(&time);
 990:	75 de       	rcall	.-790    	; 0x67c <DS3231_get_time(time_struct*) [clone .constprop.4]>
selfsetHour():
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:31
  PORTA= PORTA & B01010000;//0x00;
  DDRA = DDRA & B01010000;//0x00;
  return state;
}
void selfsetHour(){
  if(set_button_pressed()){
 992:	5f dc       	rcall	.-1858   	; 0x252 <set_button_pressed()>
 994:	88 23       	and	r24, r24
 996:	09 f4       	brne	.+2      	; 0x99a <main+0xfa>
 998:	6a c1       	rjmp	.+724    	; 0xc6e <main+0x3ce>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:32
    set_button_counter++;
 99a:	70 90 82 00 	lds	r7, 0x0082	; 0x800082 <set_button_counter>
 99e:	73 94       	inc	r7
 9a0:	70 92 82 00 	sts	0x0082, r7	; 0x800082 <set_button_counter>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:33
    unsigned long start=millis();
 9a4:	31 dc       	rcall	.-1950   	; 0x208 <millis>
 9a6:	6b 01       	movw	r12, r22
 9a8:	7c 01       	movw	r14, r24
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:38
    bool par;
//    while(set_button_pressed()&&millis()<(start+TIMESET_TIMEOUT*10)){
//      printHoras(set_button_counter, Agrupacion_M, true, false);
//    }
    if(set_button_counter==5){
 9aa:	25 e0       	ldi	r18, 0x05	; 5
 9ac:	72 12       	cpse	r7, r18
 9ae:	4d c0       	rjmp	.+154    	; 0xa4a <main+0x1aa>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:39
          while((set_button_counter==5)&&((millis()-start)<(TIMESET_TIMEOUT*500))){
 9b0:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <set_button_counter>
 9b4:	85 30       	cpi	r24, 0x05	; 5
 9b6:	d9 f5       	brne	.+118    	; 0xa2e <main+0x18e>
 9b8:	27 dc       	rcall	.-1970   	; 0x208 <millis>
 9ba:	6c 19       	sub	r22, r12
 9bc:	7d 09       	sbc	r23, r13
 9be:	8e 09       	sbc	r24, r14
 9c0:	9f 09       	sbc	r25, r15
 9c2:	60 33       	cpi	r22, 0x30	; 48
 9c4:	75 47       	sbci	r23, 0x75	; 117
 9c6:	81 05       	cpc	r24, r1
 9c8:	91 05       	cpc	r25, r1
 9ca:	88 f5       	brcc	.+98     	; 0xa2e <main+0x18e>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:40
      for(long t=millis(); (millis()-t)<600;){
 9cc:	1d dc       	rcall	.-1990   	; 0x208 <millis>
 9ce:	2b 01       	movw	r4, r22
 9d0:	3c 01       	movw	r6, r24
 9d2:	1a dc       	rcall	.-1996   	; 0x208 <millis>
 9d4:	64 19       	sub	r22, r4
 9d6:	75 09       	sbc	r23, r5
 9d8:	86 09       	sbc	r24, r6
 9da:	97 09       	sbc	r25, r7
 9dc:	68 35       	cpi	r22, 0x58	; 88
 9de:	72 40       	sbci	r23, 0x02	; 2
 9e0:	81 05       	cpc	r24, r1
 9e2:	91 05       	cpc	r25, r1
 9e4:	08 f0       	brcs	.+2      	; 0x9e8 <main+0x148>
 9e6:	a1 c0       	rjmp	.+322    	; 0xb2a <main+0x28a>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:43
        //printHoras(change_pos+1, Agrupacion_M, true, false);
        //printHoras(0x22, Agrupacion_S, false, false);
        switch (change_pos){
 9e8:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <change_pos>
 9ec:	81 30       	cpi	r24, 0x01	; 1
 9ee:	09 f4       	brne	.+2      	; 0x9f2 <main+0x152>
 9f0:	8b c0       	rjmp	.+278    	; 0xb08 <main+0x268>
 9f2:	08 f4       	brcc	.+2      	; 0x9f6 <main+0x156>
 9f4:	70 c0       	rjmp	.+224    	; 0xad6 <main+0x236>
 9f6:	82 30       	cpi	r24, 0x02	; 2
 9f8:	61 f7       	brne	.-40     	; 0x9d2 <main+0x132>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:59
              printHoras(time.hour, Horas_pins, false, true);
              printHoras(time.second, Agrupacion_S, false, false);
            }
            break;
          case 2:
            printHoras(time.second, Agrupacion_S, false, false);
 9fa:	20 e0       	ldi	r18, 0x00	; 0
 9fc:	40 e0       	ldi	r20, 0x00	; 0
 9fe:	6d e8       	ldi	r22, 0x8D	; 141
 a00:	70 e0       	ldi	r23, 0x00	; 0
 a02:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <time+0x2>
 a06:	47 dc       	rcall	.-1906   	; 0x296 <printHoras(unsigned char, int*, bool, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:60
            if(par){
 a08:	33 20       	and	r3, r3
 a0a:	19 f3       	breq	.-58     	; 0x9d2 <main+0x132>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:61
              printHoras(time.hour, Horas_pins, false, true);
 a0c:	21 e0       	ldi	r18, 0x01	; 1
 a0e:	40 e0       	ldi	r20, 0x00	; 0
 a10:	63 e8       	ldi	r22, 0x83	; 131
 a12:	70 e0       	ldi	r23, 0x00	; 0
 a14:	80 91 ae 00 	lds	r24, 0x00AE	; 0x8000ae <time>
 a18:	3e dc       	rcall	.-1924   	; 0x296 <printHoras(unsigned char, int*, bool, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:62
              printHoras(time.minute, Agrupacion_M, true, false);
 a1a:	20 e0       	ldi	r18, 0x00	; 0
 a1c:	41 e0       	ldi	r20, 0x01	; 1
 a1e:	69 e9       	ldi	r22, 0x99	; 153
 a20:	70 e0       	ldi	r23, 0x00	; 0
 a22:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <time+0x1>
 a26:	6e c0       	rjmp	.+220    	; 0xb04 <main+0x264>
PbcdCounter():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:155
  }
}
void PbcdCounter(struct time_struct *t){
  //Positive Binary coded decimal counter. In this program, each byte has 2 decimals. Internet examples use only one per byte... such a waste in memory space
  //Lets try this only with seconds first...
  t->second++;
 a28:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <time+0x2>
 a2c:	a7 cf       	rjmp	.-178    	; 0x97c <main+0xdc>
beginTransmission():
 a2e:	88 e6       	ldi	r24, 0x68	; 104
 a30:	90 db       	rcall	.-2272   	; 0x152 <USIWire::beginTransmission(unsigned char) [clone .constprop.10]>
write():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.h:72
 a32:	80 e0       	ldi	r24, 0x00	; 0
 a34:	5b db       	rcall	.-2378   	; 0xec <USIWire::write(unsigned char) [clone .constprop.15]>
DS3231_set_time():
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:23
  DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
}
void DS3231_set_time(struct time_struct *t){
  Wire.beginTransmission(DS3231_I2C_ADDR);
  Wire.write(DS3231_TIME_ADDR);
  Wire.write(t->second);
 a36:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <time+0x2>
 a3a:	58 db       	rcall	.-2384   	; 0xec <USIWire::write(unsigned char) [clone .constprop.15]>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:24
  Wire.write(t->minute);
 a3c:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <time+0x1>
 a40:	55 db       	rcall	.-2390   	; 0xec <USIWire::write(unsigned char) [clone .constprop.15]>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:25
  Wire.write(t->hour);
 a42:	80 91 ae 00 	lds	r24, 0x00AE	; 0x8000ae <time>
 a46:	52 db       	rcall	.-2396   	; 0xec <USIWire::write(unsigned char) [clone .constprop.15]>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:26
  Wire.endTransmission();
 a48:	dc dd       	rcall	.-1096   	; 0x602 <USIWire::endTransmission() [clone .constprop.11]>
loop():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:213
//  }
//  else{
//    set_button_counter=0;
//  }
  selfsetHour();
  if(select_button_pressed()){
 a4a:	ea db       	rcall	.-2092   	; 0x220 <select_button_pressed()>
 a4c:	88 23       	and	r24, r24
 a4e:	09 f4       	brne	.+2      	; 0xa52 <main+0x1b2>
 a50:	11 c1       	rjmp	.+546    	; 0xc74 <main+0x3d4>
beginTransmission():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:155
 a52:	88 e6       	ldi	r24, 0x68	; 104
 a54:	7e db       	rcall	.-2308   	; 0x152 <USIWire::beginTransmission(unsigned char) [clone .constprop.10]>
write():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.h:72
 a56:	81 e1       	ldi	r24, 0x11	; 17
 a58:	49 db       	rcall	.-2414   	; 0xec <USIWire::write(unsigned char) [clone .constprop.15]>
DS3231_get_temp():
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:32
}
int DS3231_get_temp(){
  //resetI2C();
  Wire.beginTransmission(DS3231_I2C_ADDR);
  Wire.write(DS3231_TEMP_ADDR);
  Wire.endTransmission(); 
 a5a:	d3 dd       	rcall	.-1114   	; 0x602 <USIWire::endTransmission() [clone .constprop.11]>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:35
  //if(0!=Wire.endTransmission()) return 0x22;
  uint8_t gotData = false;
  uint32_t start = millis();
 a5c:	d5 db       	rcall	.-2134   	; 0x208 <millis>
 a5e:	6b 01       	movw	r12, r22
 a60:	7c 01       	movw	r14, r24
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:36
  while(millis()-start<DS3231_TRANSACTION_TIMEOUT){
 a62:	d2 db       	rcall	.-2140   	; 0x208 <millis>
 a64:	6c 19       	sub	r22, r12
 a66:	7d 09       	sbc	r23, r13
 a68:	8e 09       	sbc	r24, r14
 a6a:	9f 09       	sbc	r25, r15
 a6c:	64 36       	cpi	r22, 0x64	; 100
 a6e:	71 05       	cpc	r23, r1
 a70:	81 05       	cpc	r24, r1
 a72:	91 05       	cpc	r25, r1
 a74:	f0 f4       	brcc	.+60     	; 0xab2 <main+0x212>
requestFrom():
/home/lukilukeskywalker/Arduino/libraries/USIWire/src/USIWire.cpp:129
}

uint8_t USIWire::requestFrom(uint8_t address, uint8_t quantity,
                             uint8_t sendStop) {
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint32_t)0,
                     (uint8_t)0, (uint8_t)sendStop);
 a76:	62 e0       	ldi	r22, 0x02	; 2
 a78:	88 e6       	ldi	r24, 0x68	; 104
 a7a:	e3 dd       	rcall	.-1082   	; 0x642 <USIWire::requestFrom(unsigned char, unsigned char, unsigned long, unsigned char, unsigned char) [clone .constprop.7]>
DS3231_get_temp():
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:37
    if(Wire.requestFrom(DS3231_I2C_ADDR, 2)==2){
 a7c:	82 30       	cpi	r24, 0x02	; 2
 a7e:	89 f7       	brne	.-30     	; 0xa62 <main+0x1c2>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:45
    }
  }
  if(!gotData){
    return;
  }
  uint8_t temp_msb = Wire.read();
 a80:	07 db       	rcall	.-2546   	; 0x90 <USIWire::read() [clone .constprop.16]>
 a82:	d8 2f       	mov	r29, r24
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:46
  uint8_t temp_lsb = Wire.read() >> 6;
 a84:	05 db       	rcall	.-2550   	; 0x90 <USIWire::read() [clone .constprop.16]>
 a86:	9c 01       	movw	r18, r24
 a88:	86 e0       	ldi	r24, 0x06	; 6
 a8a:	35 95       	asr	r19
 a8c:	27 95       	ror	r18
 a8e:	8a 95       	dec	r24
 a90:	e1 f7       	brne	.-8      	; 0xa8a <main+0x1ea>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:48
  int8_t nint;
  if((temp_msb & 0x80) !=0) nint = temp_msb | ~((1<<8) -1);
 a92:	8d 2f       	mov	r24, r29
 a94:	d7 fd       	sbrc	r29, 7
 a96:	05 c0       	rjmp	.+10     	; 0xaa2 <main+0x202>
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:49
  else nint = ((temp_msb/10)<<4)+(temp_msb%10);
 a98:	62 2d       	mov	r22, r2
 a9a:	7c d1       	rcall	.+760    	; 0xd94 <__udivmodqi4>
 a9c:	82 95       	swap	r24
 a9e:	80 7f       	andi	r24, 0xF0	; 240
 aa0:	89 0f       	add	r24, r25
/home/lukilukeskywalker/Arduino/Binary_Clock/ds3231.ino:51
  //return 0.25*temp_lsb + nint;
  return temp_lsb + (nint<<8);
 aa2:	08 2e       	mov	r0, r24
 aa4:	00 0c       	add	r0, r0
 aa6:	99 0b       	sbc	r25, r25
 aa8:	98 2f       	mov	r25, r24
 aaa:	88 27       	eor	r24, r24
 aac:	ec 01       	movw	r28, r24
 aae:	c2 0f       	add	r28, r18
 ab0:	d1 1d       	adc	r29, r1
loop():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:216
    int temperature=DS3231_get_temp();
    while(select_button_pressed()){
      printHoras(((temperature&0xFF00)>>8), Agrupacion_M, true, false);
 ab2:	fd 2e       	mov	r15, r29
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:215
//    set_button_counter=0;
//  }
  selfsetHour();
  if(select_button_pressed()){
    int temperature=DS3231_get_temp();
    while(select_button_pressed()){
 ab4:	b5 db       	rcall	.-2198   	; 0x220 <select_button_pressed()>
 ab6:	88 23       	and	r24, r24
 ab8:	09 f4       	brne	.+2      	; 0xabc <main+0x21c>
 aba:	dc c0       	rjmp	.+440    	; 0xc74 <main+0x3d4>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:216
      printHoras(((temperature&0xFF00)>>8), Agrupacion_M, true, false);
 abc:	20 e0       	ldi	r18, 0x00	; 0
 abe:	41 e0       	ldi	r20, 0x01	; 1
 ac0:	69 e9       	ldi	r22, 0x99	; 153
 ac2:	70 e0       	ldi	r23, 0x00	; 0
 ac4:	8f 2d       	mov	r24, r15
 ac6:	e7 db       	rcall	.-2098   	; 0x296 <printHoras(unsigned char, int*, bool, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:217
      printHoras((temperature&0x00FF), Agrupacion_S, false, false);
 ac8:	20 e0       	ldi	r18, 0x00	; 0
 aca:	40 e0       	ldi	r20, 0x00	; 0
 acc:	6d e8       	ldi	r22, 0x8D	; 141
 ace:	70 e0       	ldi	r23, 0x00	; 0
 ad0:	8c 2f       	mov	r24, r28
 ad2:	e1 db       	rcall	.-2110   	; 0x296 <printHoras(unsigned char, int*, bool, bool)>
 ad4:	ef cf       	rjmp	.-34     	; 0xab4 <main+0x214>
selfsetHour():
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:45
      for(long t=millis(); (millis()-t)<600;){
        //printHoras(change_pos+1, Agrupacion_M, true, false);
        //printHoras(0x22, Agrupacion_S, false, false);
        switch (change_pos){
          case 0:
            printHoras(time.hour, Horas_pins, false, true);
 ad6:	21 e0       	ldi	r18, 0x01	; 1
 ad8:	40 e0       	ldi	r20, 0x00	; 0
 ada:	63 e8       	ldi	r22, 0x83	; 131
 adc:	70 e0       	ldi	r23, 0x00	; 0
 ade:	80 91 ae 00 	lds	r24, 0x00AE	; 0x8000ae <time>
 ae2:	d9 db       	rcall	.-2126   	; 0x296 <printHoras(unsigned char, int*, bool, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:46
            if(par){
 ae4:	33 20       	and	r3, r3
 ae6:	09 f4       	brne	.+2      	; 0xaea <main+0x24a>
 ae8:	74 cf       	rjmp	.-280    	; 0x9d2 <main+0x132>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:47
              printHoras(time.minute, Agrupacion_M, true, false);
 aea:	20 e0       	ldi	r18, 0x00	; 0
 aec:	41 e0       	ldi	r20, 0x01	; 1
 aee:	69 e9       	ldi	r22, 0x99	; 153
 af0:	70 e0       	ldi	r23, 0x00	; 0
 af2:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <time+0x1>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:54
            }
            break;
          case 1:
            printHoras(time.minute, Agrupacion_M, true, false);
            if(par){
              printHoras(time.hour, Horas_pins, false, true);
 af6:	cf db       	rcall	.-2146   	; 0x296 <printHoras(unsigned char, int*, bool, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:55
              printHoras(time.second, Agrupacion_S, false, false);
 af8:	20 e0       	ldi	r18, 0x00	; 0
 afa:	40 e0       	ldi	r20, 0x00	; 0
 afc:	6d e8       	ldi	r22, 0x8D	; 141
 afe:	70 e0       	ldi	r23, 0x00	; 0
 b00:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <time+0x2>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:62
            break;
          case 2:
            printHoras(time.second, Agrupacion_S, false, false);
            if(par){
              printHoras(time.hour, Horas_pins, false, true);
              printHoras(time.minute, Agrupacion_M, true, false);
 b04:	c8 db       	rcall	.-2160   	; 0x296 <printHoras(unsigned char, int*, bool, bool)>
 b06:	65 cf       	rjmp	.-310    	; 0x9d2 <main+0x132>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:52
              printHoras(time.minute, Agrupacion_M, true, false);
              printHoras(time.second, Agrupacion_S, false, false);
            }
            break;
          case 1:
            printHoras(time.minute, Agrupacion_M, true, false);
 b08:	20 e0       	ldi	r18, 0x00	; 0
 b0a:	41 e0       	ldi	r20, 0x01	; 1
 b0c:	69 e9       	ldi	r22, 0x99	; 153
 b0e:	70 e0       	ldi	r23, 0x00	; 0
 b10:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <time+0x1>
 b14:	c0 db       	rcall	.-2176   	; 0x296 <printHoras(unsigned char, int*, bool, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:53
            if(par){
 b16:	33 20       	and	r3, r3
 b18:	09 f4       	brne	.+2      	; 0xb1c <main+0x27c>
 b1a:	5b cf       	rjmp	.-330    	; 0x9d2 <main+0x132>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:54
              printHoras(time.hour, Horas_pins, false, true);
 b1c:	21 e0       	ldi	r18, 0x01	; 1
 b1e:	40 e0       	ldi	r20, 0x00	; 0
 b20:	63 e8       	ldi	r22, 0x83	; 131
 b22:	70 e0       	ldi	r23, 0x00	; 0
 b24:	80 91 ae 00 	lds	r24, 0x00AE	; 0x8000ae <time>
 b28:	e6 cf       	rjmp	.-52     	; 0xaf6 <main+0x256>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:67
              printHoras(time.minute, Agrupacion_M, true, false);
            }
            break;
        }
      }
      par=!par;
 b2a:	21 e0       	ldi	r18, 0x01	; 1
 b2c:	32 26       	eor	r3, r18
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:68
      if(set_button_pressed()){
 b2e:	91 db       	rcall	.-2270   	; 0x252 <set_button_pressed()>
 b30:	88 23       	and	r24, r24
 b32:	69 f0       	breq	.+26     	; 0xb4e <main+0x2ae>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:69
        change_pos++;
 b34:	70 90 81 00 	lds	r7, 0x0081	; 0x800081 <change_pos>
 b38:	73 94       	inc	r7
 b3a:	70 92 81 00 	sts	0x0081, r7	; 0x800081 <change_pos>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:70
        start=millis();
 b3e:	64 db       	rcall	.-2360   	; 0x208 <millis>
 b40:	6b 01       	movw	r12, r22
 b42:	7c 01       	movw	r14, r24
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:71
        if(change_pos==3) change_pos=0;
 b44:	83 e0       	ldi	r24, 0x03	; 3
 b46:	78 12       	cpse	r7, r24
 b48:	02 c0       	rjmp	.+4      	; 0xb4e <main+0x2ae>
 b4a:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <change_pos>
pinMode():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:35
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t bit = digitalPinToBitMask(pin);
 b4e:	f8 01       	movw	r30, r16
 b50:	44 91       	lpm	r20, Z
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:36
  uint8_t port = digitalPinToPort(pin);
 b52:	f5 01       	movw	r30, r10
 b54:	84 91       	lpm	r24, Z
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:39
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
 b56:	88 23       	and	r24, r24
 b58:	c9 f0       	breq	.+50     	; 0xb8c <main+0x2ec>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:41

  reg = portModeRegister(port);
 b5a:	90 e0       	ldi	r25, 0x00	; 0
 b5c:	88 0f       	add	r24, r24
 b5e:	99 1f       	adc	r25, r25
 b60:	fc 01       	movw	r30, r24
 b62:	e8 5d       	subi	r30, 0xD8	; 216
 b64:	ff 4f       	sbci	r31, 0xFF	; 255
 b66:	a5 91       	lpm	r26, Z+
 b68:	b4 91       	lpm	r27, Z
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:42
  out = portOutputRegister(port);
 b6a:	fc 01       	movw	r30, r24
 b6c:	ee 5d       	subi	r30, 0xDE	; 222
 b6e:	ff 4f       	sbci	r31, 0xFF	; 255
 b70:	25 91       	lpm	r18, Z+
 b72:	34 91       	lpm	r19, Z
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:51
                cli();
    *reg &= ~bit;
    *out &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
    uint8_t oldSREG = SREG;
 b74:	9f b7       	in	r25, 0x3f	; 63
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:52
                cli();
 b76:	f8 94       	cli
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:53
    *reg &= ~bit;
 b78:	5c 91       	ld	r21, X
 b7a:	84 2f       	mov	r24, r20
 b7c:	80 95       	com	r24
 b7e:	85 23       	and	r24, r21
 b80:	8c 93       	st	X, r24
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:54
    *out |= bit;
 b82:	f9 01       	movw	r30, r18
 b84:	80 81       	ld	r24, Z
 b86:	48 2b       	or	r20, r24
 b88:	40 83       	st	Z, r20
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:55
    SREG = oldSREG;
 b8a:	9f bf       	out	0x3f, r25	; 63
digitalRead():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:168
}

int digitalRead(uint8_t pin)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t timer = digitalPinToTimer(pin);
 b8c:	f4 01       	movw	r30, r8
 b8e:	84 91       	lpm	r24, Z
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:169
  uint8_t bit = digitalPinToBitMask(pin);
 b90:	f8 01       	movw	r30, r16
 b92:	94 91       	lpm	r25, Z
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:170
  uint8_t port = digitalPinToPort(pin);
 b94:	f5 01       	movw	r30, r10
 b96:	24 91       	lpm	r18, Z
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:172

  if (port == NOT_A_PIN) return LOW;
 b98:	21 11       	cpse	r18, r1
 b9a:	0d c0       	rjmp	.+26     	; 0xbb6 <main+0x316>
selfsetHour():
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:75
      }
      pinMode(PA7, INPUT_PULLUP);
      if(!digitalRead(PA7)){ //if(select_button_pressed()){ //NO se... hay algo que hace que lo marque como presionado solo en esta funcion...
        switch (change_pos){
 b9c:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <change_pos>
 ba0:	81 30       	cpi	r24, 0x01	; 1
 ba2:	09 f4       	brne	.+2      	; 0xba6 <main+0x306>
 ba4:	42 c0       	rjmp	.+132    	; 0xc2a <main+0x38a>
 ba6:	80 f1       	brcs	.+96     	; 0xc08 <main+0x368>
 ba8:	82 30       	cpi	r24, 0x02	; 2
 baa:	09 f4       	brne	.+2      	; 0xbae <main+0x30e>
 bac:	4f c0       	rjmp	.+158    	; 0xc4c <main+0x3ac>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:104
                time.second=0;
              }
            }
            break;
        }
        start=millis();
 bae:	2c db       	rcall	.-2472   	; 0x208 <millis>
 bb0:	6b 01       	movw	r12, r22
 bb2:	7c 01       	movw	r14, r24
 bb4:	12 c0       	rjmp	.+36     	; 0xbda <main+0x33a>
digitalRead():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:176

  // If the pin that support PWM output, we need to turn it off
  // before getting a digital reading.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 bb6:	88 23       	and	r24, r24
 bb8:	29 f0       	breq	.+10     	; 0xbc4 <main+0x324>
turnOffPWM():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:67
}

static void turnOffPWM(uint8_t timer)
{
  #if defined(TCCR0A) && defined(COM0A1)
  if( timer == TIMER0A){
 bba:	81 30       	cpi	r24, 0x01	; 1
 bbc:	a9 f4       	brne	.+42     	; 0xbe8 <main+0x348>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:68
    cbi(TCCR0A, COM0A1);
 bbe:	80 b7       	in	r24, 0x30	; 48
 bc0:	8f 77       	andi	r24, 0x7F	; 127
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:75
  } else
  #endif

  #if defined(TCCR0A) && defined(COM0B1)
  if( timer == TIMER0B){
    cbi(TCCR0A, COM0B1);
 bc2:	80 bf       	out	0x30, r24	; 48
digitalRead():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:178

  // If the pin that support PWM output, we need to turn it off
  // before getting a digital reading.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  if (*portInputRegister(port) & bit) return HIGH;
 bc4:	e2 2f       	mov	r30, r18
 bc6:	f0 e0       	ldi	r31, 0x00	; 0
 bc8:	ee 0f       	add	r30, r30
 bca:	ff 1f       	adc	r31, r31
 bcc:	e2 5d       	subi	r30, 0xD2	; 210
 bce:	ff 4f       	sbci	r31, 0xFF	; 255
 bd0:	a5 91       	lpm	r26, Z+
 bd2:	b4 91       	lpm	r27, Z
 bd4:	8c 91       	ld	r24, X
 bd6:	98 23       	and	r25, r24
 bd8:	09 f3       	breq	.-62     	; 0xb9c <main+0x2fc>
selfsetHour():
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:106
      }
      PORTA= PORTA & B01010000;//0x00;
 bda:	8b b3       	in	r24, 0x1b	; 27
 bdc:	80 75       	andi	r24, 0x50	; 80
 bde:	8b bb       	out	0x1b, r24	; 27
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:107
      DDRA = DDRA & B01010000;//0x00;
 be0:	8a b3       	in	r24, 0x1a	; 26
 be2:	80 75       	andi	r24, 0x50	; 80
 be4:	8a bb       	out	0x1a, r24	; 26
 be6:	e4 ce       	rjmp	.-568    	; 0x9b0 <main+0x110>
turnOffPWM():
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:74
    //cbi(TCCR0A, COM0A0);
  } else
  #endif

  #if defined(TCCR0A) && defined(COM0B1)
  if( timer == TIMER0B){
 be8:	82 30       	cpi	r24, 0x02	; 2
 bea:	19 f4       	brne	.+6      	; 0xbf2 <main+0x352>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:75
    cbi(TCCR0A, COM0B1);
 bec:	80 b7       	in	r24, 0x30	; 48
 bee:	8f 7d       	andi	r24, 0xDF	; 223
 bf0:	e8 cf       	rjmp	.-48     	; 0xbc2 <main+0x322>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:81
    //cbi(TCCR0A, COM0B0);
  } else
  #endif

  #if defined(TCCR1A) && defined(COM1A1)
  if( timer == TIMER1A){
 bf2:	83 30       	cpi	r24, 0x03	; 3
 bf4:	21 f4       	brne	.+8      	; 0xbfe <main+0x35e>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:82
    cbi(TCCR1A, COM1A1);
 bf6:	8f b5       	in	r24, 0x2f	; 47
 bf8:	8f 77       	andi	r24, 0x7F	; 127
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:116
  } else
  #endif

  #if defined(TCCR1A) && defined(COM1B1)
  if( timer == TIMER1B){
    cbi(TCCR1A, COM1B1);
 bfa:	8f bd       	out	0x2f, r24	; 47
 bfc:	e3 cf       	rjmp	.-58     	; 0xbc4 <main+0x324>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:115
  #endif
  } else
  #endif

  #if defined(TCCR1A) && defined(COM1B1)
  if( timer == TIMER1B){
 bfe:	84 30       	cpi	r24, 0x04	; 4
 c00:	09 f7       	brne	.-62     	; 0xbc4 <main+0x324>
/home/lukilukeskywalker/.arduino15/packages/ATTinyCore/hardware/avr/1.3.3/cores/tiny/wiring_digital.c:116
    cbi(TCCR1A, COM1B1);
 c02:	8f b5       	in	r24, 0x2f	; 47
 c04:	8f 7d       	andi	r24, 0xDF	; 223
 c06:	f9 cf       	rjmp	.-14     	; 0xbfa <main+0x35a>
selfsetHour():
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:77
      }
      pinMode(PA7, INPUT_PULLUP);
      if(!digitalRead(PA7)){ //if(select_button_pressed()){ //NO se... hay algo que hace que lo marque como presionado solo en esta funcion...
        switch (change_pos){
          case 0:
            time.hour++;
 c08:	80 91 ae 00 	lds	r24, 0x00AE	; 0x8000ae <time>
 c0c:	8f 5f       	subi	r24, 0xFF	; 255
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:78
          if(!((time.hour&0x0F)^0x0A)){
 c0e:	98 2f       	mov	r25, r24
 c10:	9f 70       	andi	r25, 0x0F	; 15
 c12:	9a 30       	cpi	r25, 0x0A	; 10
 c14:	29 f4       	brne	.+10     	; 0xc20 <main+0x380>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:79
            time.hour=(time.hour&0x30)+0x10;
 c16:	80 73       	andi	r24, 0x30	; 48
 c18:	80 5f       	subi	r24, 0xF0	; 240
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:77
      }
      pinMode(PA7, INPUT_PULLUP);
      if(!digitalRead(PA7)){ //if(select_button_pressed()){ //NO se... hay algo que hace que lo marque como presionado solo en esta funcion...
        switch (change_pos){
          case 0:
            time.hour++;
 c1a:	80 93 ae 00 	sts	0x00AE, r24	; 0x8000ae <time>
 c1e:	c7 cf       	rjmp	.-114    	; 0xbae <main+0x30e>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:81
          if(!((time.hour&0x0F)^0x0A)){
            time.hour=(time.hour&0x30)+0x10;
          }
          else if(time.hour==0x24){
 c20:	84 32       	cpi	r24, 0x24	; 36
 c22:	d9 f7       	brne	.-10     	; 0xc1a <main+0x37a>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:82
            time.hour=0;
 c24:	10 92 ae 00 	sts	0x00AE, r1	; 0x8000ae <time>
 c28:	c2 cf       	rjmp	.-124    	; 0xbae <main+0x30e>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:86
          }
            break;
          case 1:
            time.minute++;
 c2a:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <time+0x1>
 c2e:	8f 5f       	subi	r24, 0xFF	; 255
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:87
            if(!((time.minute&0x0F)^0x0A)){
 c30:	98 2f       	mov	r25, r24
 c32:	9f 70       	andi	r25, 0x0F	; 15
 c34:	9a 30       	cpi	r25, 0x0A	; 10
 c36:	19 f0       	breq	.+6      	; 0xc3e <main+0x39e>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:88
              time.minute=(time.minute&0xF0)+0x10;
 c38:	80 93 af 00 	sts	0x00AF, r24	; 0x8000af <time+0x1>
 c3c:	b8 cf       	rjmp	.-144    	; 0xbae <main+0x30e>
 c3e:	80 7f       	andi	r24, 0xF0	; 240
 c40:	80 5f       	subi	r24, 0xF0	; 240
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:89
              if(!((time.minute&0xF0)^0x60)){
 c42:	80 36       	cpi	r24, 0x60	; 96
 c44:	c9 f7       	brne	.-14     	; 0xc38 <main+0x398>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:90
                time.minute=0;
 c46:	10 92 af 00 	sts	0x00AF, r1	; 0x8000af <time+0x1>
 c4a:	b1 cf       	rjmp	.-158    	; 0xbae <main+0x30e>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:95
              }
            }
          break;
          case 2:
            time.second++;
 c4c:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <time+0x2>
 c50:	8f 5f       	subi	r24, 0xFF	; 255
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:96
            if(!((time.second&0x0F)^0x0A)){
 c52:	98 2f       	mov	r25, r24
 c54:	9f 70       	andi	r25, 0x0F	; 15
 c56:	9a 30       	cpi	r25, 0x0A	; 10
 c58:	19 f0       	breq	.+6      	; 0xc60 <main+0x3c0>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:97
              time.second=(time.second&0xF0)+0x10;
 c5a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <time+0x2>
 c5e:	a7 cf       	rjmp	.-178    	; 0xbae <main+0x30e>
 c60:	80 7f       	andi	r24, 0xF0	; 240
 c62:	80 5f       	subi	r24, 0xF0	; 240
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:98
              if(!((time.second&0xF0)^0x60)){
 c64:	80 36       	cpi	r24, 0x60	; 96
 c66:	c9 f7       	brne	.-14     	; 0xc5a <main+0x3ba>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:99
                time.second=0;
 c68:	10 92 b0 00 	sts	0x00B0, r1	; 0x8000b0 <time+0x2>
 c6c:	a0 cf       	rjmp	.-192    	; 0xbae <main+0x30e>
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:115
    DS3231_set_time(&time);
    }

  }
  else{
    set_button_counter=0;
 c6e:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <set_button_counter>
 c72:	eb ce       	rjmp	.-554    	; 0xa4a <main+0x1aa>
loop():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:221
      //printHoras((temperature), Agrupacion_M, true, false);
    }
  }
  while(millis()-time_elapsed<1000){
 c74:	c9 da       	rcall	.-2670   	; 0x208 <millis>
 c76:	c0 90 89 00 	lds	r12, 0x0089	; 0x800089 <time_elapsed>
 c7a:	d0 90 8a 00 	lds	r13, 0x008A	; 0x80008a <time_elapsed+0x1>
 c7e:	e0 90 8b 00 	lds	r14, 0x008B	; 0x80008b <time_elapsed+0x2>
 c82:	f0 90 8c 00 	lds	r15, 0x008C	; 0x80008c <time_elapsed+0x3>
 c86:	6c 19       	sub	r22, r12
 c88:	7d 09       	sbc	r23, r13
 c8a:	8e 09       	sbc	r24, r14
 c8c:	9f 09       	sbc	r25, r15
 c8e:	68 3e       	cpi	r22, 0xE8	; 232
 c90:	73 40       	sbci	r23, 0x03	; 3
 c92:	81 05       	cpc	r24, r1
 c94:	91 05       	cpc	r25, r1
 c96:	b0 f4       	brcc	.+44     	; 0xcc4 <main+0x424>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:222
    printHoras(time.hour, Horas_pins, false, true);
 c98:	21 e0       	ldi	r18, 0x01	; 1
 c9a:	40 e0       	ldi	r20, 0x00	; 0
 c9c:	63 e8       	ldi	r22, 0x83	; 131
 c9e:	70 e0       	ldi	r23, 0x00	; 0
 ca0:	80 91 ae 00 	lds	r24, 0x00AE	; 0x8000ae <time>
 ca4:	f8 da       	rcall	.-2576   	; 0x296 <printHoras(unsigned char, int*, bool, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:223
    printHoras(time.minute, Agrupacion_M, true, false);
 ca6:	20 e0       	ldi	r18, 0x00	; 0
 ca8:	41 e0       	ldi	r20, 0x01	; 1
 caa:	69 e9       	ldi	r22, 0x99	; 153
 cac:	70 e0       	ldi	r23, 0x00	; 0
 cae:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <time+0x1>
 cb2:	f1 da       	rcall	.-2590   	; 0x296 <printHoras(unsigned char, int*, bool, bool)>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:224
    printHoras(time.second, Agrupacion_S, false, false);
 cb4:	20 e0       	ldi	r18, 0x00	; 0
 cb6:	40 e0       	ldi	r20, 0x00	; 0
 cb8:	6d e8       	ldi	r22, 0x8D	; 141
 cba:	70 e0       	ldi	r23, 0x00	; 0
 cbc:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <time+0x2>
 cc0:	ea da       	rcall	.-2604   	; 0x296 <printHoras(unsigned char, int*, bool, bool)>
 cc2:	d8 cf       	rjmp	.-80     	; 0xc74 <main+0x3d4>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:226
  }
  time_elapsed=millis();
 cc4:	a1 da       	rcall	.-2750   	; 0x208 <millis>
 cc6:	60 93 89 00 	sts	0x0089, r22	; 0x800089 <time_elapsed>
 cca:	70 93 8a 00 	sts	0x008A, r23	; 0x80008a <time_elapsed+0x1>
 cce:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <time_elapsed+0x2>
 cd2:	90 93 8c 00 	sts	0x008C, r25	; 0x80008c <time_elapsed+0x3>
PbcdCounter():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:155
  }
}
void PbcdCounter(struct time_struct *t){
  //Positive Binary coded decimal counter. In this program, each byte has 2 decimals. Internet examples use only one per byte... such a waste in memory space
  //Lets try this only with seconds first...
  t->second++;
 cd6:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <time+0x2>
 cda:	8f 5f       	subi	r24, 0xFF	; 255
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:157
  //byte contra = (number & 0xF0)+0x0A;
  if(!((t->second&0x0F)^0x0A)){//if(!((number^0x0A)<<5)){//if(!((number&0x0F)^0x0A)){//if(!(number^contra)){
 cdc:	98 2f       	mov	r25, r24
 cde:	9f 70       	andi	r25, 0x0F	; 15
 ce0:	9a 30       	cpi	r25, 0x0A	; 10
 ce2:	09 f0       	breq	.+2      	; 0xce6 <main+0x446>
 ce4:	a1 ce       	rjmp	.-702    	; 0xa28 <main+0x188>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:158
     t->second=(t->second&0xF0)+0x10;
 ce6:	80 7f       	andi	r24, 0xF0	; 240
 ce8:	80 5f       	subi	r24, 0xF0	; 240
 cea:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <time+0x2>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:159
     if(!((t->second&0xF0)^0x60)){
 cee:	80 36       	cpi	r24, 0x60	; 96
 cf0:	09 f0       	breq	.+2      	; 0xcf4 <main+0x454>
 cf2:	44 ce       	rjmp	.-888    	; 0x97c <main+0xdc>
 cf4:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <time+0x1>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:160
      t->second=0;
 cf8:	10 92 b0 00 	sts	0x00B0, r1	; 0x8000b0 <time+0x2>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:161
      t->minute++;
 cfc:	8f 5f       	subi	r24, 0xFF	; 255
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:162
      if(!((t->minute&0x0F)^0x0A)){//if(!((number^0x0A)<<5)){//if(!((number&0x0F)^0x0A)){//if(!(number^contra)){
 cfe:	98 2f       	mov	r25, r24
 d00:	9f 70       	andi	r25, 0x0F	; 15
 d02:	9a 30       	cpi	r25, 0x0A	; 10
 d04:	19 f0       	breq	.+6      	; 0xd0c <main+0x46c>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:163
        t->minute=(t->minute&0xF0)+0x10;
 d06:	80 93 af 00 	sts	0x00AF, r24	; 0x8000af <time+0x1>
 d0a:	38 ce       	rjmp	.-912    	; 0x97c <main+0xdc>
 d0c:	80 7f       	andi	r24, 0xF0	; 240
 d0e:	80 5f       	subi	r24, 0xF0	; 240
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:164
        if(!((t->minute&0xF0)^0x60)){
 d10:	80 36       	cpi	r24, 0x60	; 96
 d12:	c9 f7       	brne	.-14     	; 0xd06 <main+0x466>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:165
          t->minute=0;
 d14:	10 92 af 00 	sts	0x00AF, r1	; 0x8000af <time+0x1>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:166
          t->hour++;
 d18:	80 91 ae 00 	lds	r24, 0x00AE	; 0x8000ae <time>
 d1c:	8f 5f       	subi	r24, 0xFF	; 255
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:167
          if(!((t->hour&0x0F)^0x0A)){
 d1e:	98 2f       	mov	r25, r24
 d20:	9f 70       	andi	r25, 0x0F	; 15
 d22:	9a 30       	cpi	r25, 0x0A	; 10
 d24:	29 f4       	brne	.+10     	; 0xd30 <main+0x490>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:168
            t->hour=(t->hour&0x30)+0x10;
 d26:	80 73       	andi	r24, 0x30	; 48
 d28:	80 5f       	subi	r24, 0xF0	; 240
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:166
      t->minute++;
      if(!((t->minute&0x0F)^0x0A)){//if(!((number^0x0A)<<5)){//if(!((number&0x0F)^0x0A)){//if(!(number^contra)){
        t->minute=(t->minute&0xF0)+0x10;
        if(!((t->minute&0xF0)^0x60)){
          t->minute=0;
          t->hour++;
 d2a:	80 93 ae 00 	sts	0x00AE, r24	; 0x8000ae <time>
 d2e:	26 ce       	rjmp	.-948    	; 0x97c <main+0xdc>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:170
          if(!((t->hour&0x0F)^0x0A)){
            t->hour=(t->hour&0x30)+0x10;
          }
          else if(t->hour==0x24){
 d30:	84 32       	cpi	r24, 0x24	; 36
 d32:	d9 f7       	brne	.-10     	; 0xd2a <main+0x48a>
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:171
            t->hour=0;
 d34:	10 92 ae 00 	sts	0x00AE, r1	; 0x8000ae <time>
 d38:	21 ce       	rjmp	.-958    	; 0x97c <main+0xdc>

00000d3a <_GLOBAL__sub_I_led_pins>:
_GLOBAL__sub_I_led_pins():
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:22
#define BUTTONS 7 //I think I will look for the button pressed by toggling the led_pins 
#define SET_PIN led_pins[0]
#define SELECT_PIN led_pins[1]
#endif
#define TIMESET_TIMEOUT 60    //60 seconds to make a change.
int Horas_pins[]={led_pins[0], led_pins[1], led_pins[2]};
 d3a:	e3 e8       	ldi	r30, 0x83	; 131
 d3c:	f0 e0       	ldi	r31, 0x00	; 0
 d3e:	11 82       	std	Z+1, r1	; 0x01
 d40:	10 82       	st	Z, r1
 d42:	41 e0       	ldi	r20, 0x01	; 1
 d44:	50 e0       	ldi	r21, 0x00	; 0
 d46:	53 83       	std	Z+3, r21	; 0x03
 d48:	42 83       	std	Z+2, r20	; 0x02
 d4a:	22 e0       	ldi	r18, 0x02	; 2
 d4c:	30 e0       	ldi	r19, 0x00	; 0
 d4e:	35 83       	std	Z+5, r19	; 0x05
 d50:	24 83       	std	Z+4, r18	; 0x04
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:26
int Minutos_pins[]={led_pins[0], led_pins[1], led_pins[4]};
int Segundos_pins[]={led_pins[2], led_pins[3], led_pins[4]};
int Agrupacion_H[]={led_pins[0],led_pins[1],led_pins[2],led_pins[0],led_pins[1],led_pins[2]};
int Agrupacion_M[]={led_pins[0],led_pins[3],led_pins[1], led_pins[0], led_pins[1], led_pins[4]};
 d52:	e9 e9       	ldi	r30, 0x99	; 153
 d54:	f0 e0       	ldi	r31, 0x00	; 0
 d56:	11 82       	std	Z+1, r1	; 0x01
 d58:	10 82       	st	Z, r1
 d5a:	83 e0       	ldi	r24, 0x03	; 3
 d5c:	90 e0       	ldi	r25, 0x00	; 0
 d5e:	93 83       	std	Z+3, r25	; 0x03
 d60:	82 83       	std	Z+2, r24	; 0x02
 d62:	55 83       	std	Z+5, r21	; 0x05
 d64:	44 83       	std	Z+4, r20	; 0x04
 d66:	17 82       	std	Z+7, r1	; 0x07
 d68:	16 82       	std	Z+6, r1	; 0x06
 d6a:	51 87       	std	Z+9, r21	; 0x09
 d6c:	40 87       	std	Z+8, r20	; 0x08
 d6e:	45 e0       	ldi	r20, 0x05	; 5
 d70:	50 e0       	ldi	r21, 0x00	; 0
 d72:	53 87       	std	Z+11, r21	; 0x0b
 d74:	42 87       	std	Z+10, r20	; 0x0a
/home/lukilukeskywalker/Arduino/Binary_Clock/Binary_Clock.ino:27
int Agrupacion_S[]={led_pins[0],led_pins[3],led_pins[2],led_pins[2],led_pins[3],led_pins[4]};
 d76:	ed e8       	ldi	r30, 0x8D	; 141
 d78:	f0 e0       	ldi	r31, 0x00	; 0
 d7a:	11 82       	std	Z+1, r1	; 0x01
 d7c:	10 82       	st	Z, r1
 d7e:	93 83       	std	Z+3, r25	; 0x03
 d80:	82 83       	std	Z+2, r24	; 0x02
 d82:	35 83       	std	Z+5, r19	; 0x05
 d84:	24 83       	std	Z+4, r18	; 0x04
 d86:	37 83       	std	Z+7, r19	; 0x07
 d88:	26 83       	std	Z+6, r18	; 0x06
 d8a:	91 87       	std	Z+9, r25	; 0x09
 d8c:	80 87       	std	Z+8, r24	; 0x08
 d8e:	53 87       	std	Z+11, r21	; 0x0b
 d90:	42 87       	std	Z+10, r20	; 0x0a
/home/lukilukeskywalker/Arduino/Binary_Clock/set_clock.ino:118
  }
  
}
 d92:	08 95       	ret

00000d94 <__udivmodqi4>:
__udivmodqi4():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1346
 d94:	99 1b       	sub	r25, r25
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1347
 d96:	79 e0       	ldi	r23, 0x09	; 9
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1348
 d98:	04 c0       	rjmp	.+8      	; 0xda2 <__udivmodqi4_ep>

00000d9a <__udivmodqi4_loop>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1350
 d9a:	99 1f       	adc	r25, r25
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1351
 d9c:	96 17       	cp	r25, r22
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1352
 d9e:	08 f0       	brcs	.+2      	; 0xda2 <__udivmodqi4_ep>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1353
 da0:	96 1b       	sub	r25, r22

00000da2 <__udivmodqi4_ep>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1355
 da2:	88 1f       	adc	r24, r24
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1356
 da4:	7a 95       	dec	r23
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1357
 da6:	c9 f7       	brne	.-14     	; 0xd9a <__udivmodqi4_loop>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1358
 da8:	80 95       	com	r24
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1360
 daa:	08 95       	ret

00000dac <__tablejump2__>:
__tablejump2__():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 dac:	ee 0f       	add	r30, r30
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 dae:	ff 1f       	adc	r31, r31
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 db0:	05 90       	lpm	r0, Z+
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 db2:	f4 91       	lpm	r31, Z
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 db4:	e0 2d       	mov	r30, r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 db6:	09 94       	ijmp

00000db8 <_exit>:
exit():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 db8:	f8 94       	cli

00000dba <__stop_program>:
__stop_program():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 dba:	ff cf       	rjmp	.-2      	; 0xdba <__stop_program>
